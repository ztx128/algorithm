![ICPCLogo](C:\Users\ztx\Pictures\Camera Roll\ICPCLogo.png)

  <div style="border-top: 10px solid black; margin: 10px auto; width: 65%;"></div>



<div style="text-align: center; font-size: 35px; font-family: 'Microsoft YaHei', sans-serif; font-weight: bold;">
ğ”…ğ”©ğ”²ğ”¢ğ”¶ğ”¢ğ”°_ğ”³ğ”Ÿğ”°â€˜s XCPC
</div>



<div style="text-align: center; font-size: 35px; font-family: 'Microsoft YaHei', sans-serif; font-weight: bold;">
Algorithm Template(&#8544)
</div>














<div style="text-align: center; font-size: 30px; font-family: 'Microsoft YaHei', sans-serif; font-weight: bold;">
v1.2 2026.02.06
</div>




<div style="text-align: center; font-size: 28px; font-family: 'Microsoft YaHei', sans-serif; font-weight: bold;">
Author : Blueyes_vbs
</div>

<div style="page-break-after: always;"></div>

<div class="æ±‰ä»ªç˜¦é‡‘ä½“"> <h2 style="text-align:center; font-size: 50px;"> ç›®å½•</div>

#### 1 [æ•°æ®ç»“æ„](# 1 æ•°æ®ç»“æ„) ...... 4

- 1.1 æ ‘çŠ¶æ•°ç»„
- 1.2 çº¿æ®µæ ‘
- 1.3 ä¸»å¸­æ ‘ 
- 1.4 Trieæ ‘
- 1.5 STè¡¨

#### 2 [æ‚ç±»](# 2 æ‚ç±») ...... 11

- 2.0 å¤´æ–‡ä»¶
- 2.1 å¯¹æ‹
  - 2.1.1 checker.cpp
- 2.2 äºŒåˆ†
- 2.3 éšæœºæ•°
- 2.4 å¿«é€Ÿå¹‚åŠå¿«è¯»å¿«å†™
- 2.5 Lambdaå‡½æ•°
- 2.6 STL
- 2.7 å…¨æ’åˆ—å‡½æ•° 
- 2.8 å‰ç¼€å’Œå·®åˆ†
- 2.9 è®°å¿†åŒ–æœç´¢
- 2.10 æ’åº


#### 3 [å­—ç¬¦ä¸²](# 3 å­—ç¬¦ä¸²) ...... 20

- 3.1 KMP1
- 3.2 KMP2
- 3.3 å›æ–‡ä¸²ä¸ªæ•°
- 3.4 å­—ç¬¦ä¸²å“ˆå¸Œ

#### 4 [æœç´¢ä¸å›¾è®º](# 4 æœç´¢ä¸å›¾è®º) ...... 23

- 4.1 Dijkstra
- 4.2 åˆ†å±‚å›¾æœ€çŸ­è·¯
- 4.3 Floyd 
- 4.4 Kruskal
- 4.5 Prim
- 4.6 SPFA
- 4.7 æ‹“æ‰‘æ’åº
- 4.8 ä¸‰ç±»å¹¶æŸ¥é›†
- 4.9 æ ‘çš„ç›´å¾„
- 4.10 æœ€è¿‘å…¬å…±ç¥–å…ˆ
- 4.11 SCC(å¼ºè¿é€šåˆ†é‡)
- 4.12 IDDFS
- 4.13 åŒå‘bfs
- 4.14 Astar
- 4.15 ç¯çš„å¤§å°
- 4.16 åŒå‘dfs
- 4.17 IDAstar
- 4.18 dfså‰ªæ
- 4.19 ksmä¼˜åŒ–æœ€çŸ­è·¯
- 4.20 æœ€å°ç¯ï¼ˆfloydï¼‰
- 4.21 æœ€å°ç¯ï¼ˆdfsï¼‰
- 4.22 eDCC(è¾¹åŒè¿é€šåˆ†é‡)
- 4.23 vDCC(ç‚¹åŒè¿é€šåˆ†é‡)
- 4.24 åŒˆç‰™åˆ©ç®—æ³•
- 4.25 æ¬§æ‹‰å›è·¯(è·¯å¾„)

#### 5 [æ•°è®º](# 5 æ•°è®º) ...... 41

- 5.1 é«˜ç²¾åº¦
- 5.2 çº¿æ€§ç­› 
- 5.3 è£´èœ€å®šç†
- 5.4 æ‰©å±•æ¬§å‡ é‡Œå¾—
- 5.5 gcd
- 5.6 æ•°è®ºåˆ†å—
- 5.7 çº¦æ•°ä¸ªæ•°
- 5.8 è¯•é™¤æ³•
- 5.9 è§„å¾‹
- 5.10 é€†åºå¯¹
- 5.11 è«é˜Ÿ
- 5.12 FFT

#### 6 [DPå¤§ç±»](# 6 DPå¤§ç±») ...... 52

- 6.1 å¤šé‡èƒŒåŒ…

- 6.2 åŒºé—´dp

- 6.3 æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼ˆè´ªå¿ƒä¼˜åŒ–ï¼‰

- 6.4 æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆè´ªå¿ƒä¼˜åŒ–ï¼‰

- 6.5 æœ€é•¿å…¬å…±ä¸Šå‡å­åºåˆ—

- 6.6 çŠ¶å‹dp

- 6.7 æœŸæœ›dp

- 6.8 æ ‘å½¢dp

- 6.9 æ•°ä½dp

- 6.10 å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–dp

- 6.11 æ–œç‡ä¼˜åŒ–dp

- 6.12 å·®å€¼èƒŒåŒ…

- 6.13 æ¢æ ¹dp

- 6.14 çŸ©é˜µå¿«é€Ÿå¹‚ä¼˜åŒ–dp

#### 7 [è®¡ç®—å‡ ä½•](# 7 è®¡ç®—å‡ ä½•) ...... 64

- 7.1 å‡¸åŒ…

<div style="page-break-after: always;"></div>

# 1 æ•°æ®ç»“æ„

## 1.1 æ ‘çŠ¶æ•°ç»„

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=1e5+10;
int a[MAXN];//åŸæ•°ç»„
int b[MAXN];//æ ‘çŠ¶æ•°ç»„ï¼Œç»´æŠ¤åŸæ•°ç»„çš„ï¼Œå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢

int lowbit(int x){
    return x&-x;//æ‰¾åˆ°xæœ€å³è¾¹çš„1
}

int n;//æ•°ç»„å®é™…å¤§å°
void add(int x,int num){
    for(int i=x;i<=n;i+=lowbit(i)){
        b[i]+=num;
    }
}

int sum(int r){
    int ans=0;
    for(int i=r;i>0;i-=lowbit(i)){
        ans+=b[i];
    }
    return ans;
}

int query(int l,int r){
    return sum(r)-sum(l-1);
}

void init(int n){
    for(int i=1;i<=n;i++){
        add(i,a[i]);
    }
}
//**********************************************************************************************
//åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢
int Tree1[MAXN];//ç»´æŠ¤D[i]çš„æ ‘çŠ¶æ•°ç»„
int Tree2[MAXN];//ç»´æŠ¤(i-1)*D[i]çš„æ ‘çŠ¶æ•°ç»„
void add(int Tree[],int x,int num){
    for(int i=x;i<=n;i+=lowbit(i)){
        Tree[i]+=num;
    }
}

void add1(int l,int r,int num){//åŒºé—´ä¿®æ”¹
    add(Tree1,l,num);
    add(Tree1,r+1,-num);
    add(Tree2,l,(l-1)*num);
    add(Tree2,r+1,-r*num);
}
int sum(int Tree[],int r){
    int ans=0;
    for(int i=r;i>0;i-=lowbit(i)){
        ans+=Tree[i];
    }
    return ans;
}
int query1(int l,int r){//åŒºé—´æŸ¥è¯¢
    return r*sum(Tree1,r)-(l-1)*sum(Tree1,l-1)-(sum(Tree2,r)-sum(Tree2,l-1));
}
void init1(int n){
    for(int i=1;i<=n;i++){
        add1(i,i,a[i]);
    }
}

signed main(){
    n=5;
    for(int i=1;i<=5;i++){
        cin>>a[i];
    }
    init1(5);
    add(1,2,5);
    cout<<query1(1,5)<<" ";
    return 0;
}
```

## 1.2 çº¿æ®µæ ‘

```cpp
//èŒƒå›´ä¿®æ”¹ï¼ŒèŒƒå›´æŸ¥è¯¢
#include<iostream>
using namespace std;
#define ll long long
const int N=1e6+1;
int n,m;
int w[N];

struct Node{
    int l,r;
    ll sum;             //sumè¦ç”¨llå­˜å‚¨ï¼Œé˜²æ­¢çˆ†æ‰int
    ll lazy;
}tree[N<<2];

void pushup(int u){      //æ±‚çˆ¶èŠ‚ç‚¹çš„å’Œ
    tree[u].sum = tree[u<<1].sum + tree[u<<1|1].sum;
}

void pushdown(int u){    //å°†æ‡’æƒ°æ ‡è®°å¾€ä¸‹ä¼ 
    ll lazy = tree[u].lazy;
    if(lazy){
        tree[u<<1].lazy += lazy;
        tree[u<<1|1].lazy += lazy;
        tree[u<<1].sum += (tree[u<<1].r - tree[u<<1].l + 1) * lazy;
        tree[u<<1|1].sum += (tree[u<<1|1].r - tree[u<<1|1].l + 1) * lazy;
        tree[u].lazy = 0;   //çˆ¶èŠ‚ç‚¹æ‡’æƒ°æ ‡è®°ä¼ å®Œä¹‹åä¸€å®šè¦å°†çˆ¶èŠ‚ç‚¹çš„æ‡’æƒ°æ ‡è®°é‡ç½®ä¸º0
    }
}

void build(int u,int l,int r){           //å»ºçº¿æ®µæ ‘
    if(l == r)  tree[u] = {l, r, w[r]};
    else{
        tree[u] = {l, r};
        int mid = (l+r) >> 1;
        build(u<<1, l, mid), build(u<<1|1, mid+1, r);
        pushup(u);
    }
}

ll query(int u,int l,int r){             //æ±‚åŒºé—´å’Œ
    if(l <= tree[u].l && tree[u].r <= r)    return tree[u].sum;
    else{
        pushdown(u);                    //å¦‚æœçˆ¶èŠ‚ç‚¹æ²¡æœ‰è¢«å®Œå…¨è¦†ç›–ï¼Œæ­¤æ—¶è¦è®°å¾—å°†æ‡’æƒ°æ ‡è®°å¾€ä¸‹ä¼ ã€‚
        int mid = (tree[u].l + tree[u].r) >> 1;
        ll sum = 0;
        if(l <= mid)  sum += query(u<<1, l, r);
        if(r > mid)   sum += query(u<<1|1, l, r);
        return sum;
    }
}

void update(int u,int l,int r,int d){    //åŒºé—´ä¿®æ”¹
    if(l <= tree[u].l && tree[u].r <= r){          //å®Œå…¨è¦†ç›–çˆ¶èŠ‚ç‚¹ï¼Œåˆ™æ ‡è®°ä¸€ä¸‹æ‡’æƒ°æ ‡è®°å³å¯ï¼Œå…ˆä¸ç€æ€¥å¾€ä¸‹ä¼ ï¼Œæ±‚å’Œéœ€è¦ç”¨åˆ°æ—¶å†å¾€ä¸‹ä¼ 
        tree[u].lazy += d;
        tree[u].sum += (tree[u].r - tree[u].l + 1) * d;
    }
    else{
        pushdown(u);
        int mid = tree[u].l + tree[u].r >> 1;
        if(l <= mid)  update(u<<1, l, r, d);
        if(r > mid)  update(u<<1|1, l, r, d);
        pushup(u);
    }
}

signed main(){
    cin>>n>>m;
    for(int i = 1; i <= n; i++){
        cin>>w[i];
    }
    build(1, 1, n);
    // cout<<tree[5].lazy<<endl;
    for(int i = 0; i<m; i++){
        int op = 1;
        cin>>op;
        if(op == 1){
            int l, r, d;
            cin>>l>>r>>d;
            update(1, l, r, d);
        }
        else{
            int l, r;
            cin>>l>>r;
            cout<<query(1, l ,r)<<endl;
        }
    }
    return 0;
}
```

## 1.3 ä¸»å¸­æ ‘

```cpp
#include<bits/stdc++.h>
const int MAXN = 1e5 + 10;
using namespace std;

class segTree{
public:
    struct node{
        int l, r;
        int sum;
    };

    int n;
    int cnt;
    vector<node>t;

    segTree() = default;
    segTree(int _n) : n(_n){
        assert(n > 0);
        cnt = 0;
        t.resize(n << 5);
    }

    void clear(){
        cnt = 0;
        fill(t.begin(), t.end(), node());
    }

    int build(int l ,int r){
        int u = ++cnt;
        if(l >= r) return u;
        int mid = (l + r) >> 1;
        t[u].l = build(l, mid);
        t[u].r = build(mid+1, r);
        return u;
    }

    int update(int pre, int l, int r, int x){
        int u = ++cnt;
        t[u] = t[pre];
        t[u].sum = t[pre].sum + 1;
        if(l >= r) return u;

        int mid = (l + r) >> 1;
        if(x <= mid) t[u].l = update(t[pre].l, l, mid, x);
        else t[u].r = update(t[pre].r, mid + 1, r, x);

        return u;
    }

    int kth(int u, int v, int l, int r, int k){
        if(l == r) return l;
        int cnt1 = t[t[v].l].sum - t[t[u].l].sum;
        int mid = (l + r) >> 1;

        if(k <= cnt1) return kth(t[u].l, t[v].l, l, mid, k);
        else return kth(t[u].r, t[v].r, mid+1, r, k-cnt1);
    }
};

int n, m, root[MAXN], a[MAXN], b[MAXN];
segTree tree(MAXN);

signed main(){
    map<int, int>mp;
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> a[i], mp[a[i]] = 0;
    int cnt = 0;
    for(auto &[x, y] : mp){
        y = ++cnt, b[cnt] = x;
    }

    for(int i = 1; i <= n; i++){
        root[i] = tree.update(root[i-1], 1, cnt, mp[a[i]]);
    }
    while(m--){
        int i, j, k;
        cin >> i >> j >> k;
        int idx = tree.kth(root[i-1], root[j], 1, cnt, k);
        cout << b[idx] << endl; 
    }
    return 0;
}
```

## 1.4 Trieæ ‘

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
int son[N][26], cnt[N], idx;
char str[N];

void insert(string& s)
{
    int p = 0;  //ç±»ä¼¼æŒ‡é’ˆï¼ŒæŒ‡å‘å½“å‰èŠ‚ç‚¹
    for(int i = 0; i < s.size(); i++)
    {
        int u = s[i] - 'a'; //å°†å­—æ¯è½¬åŒ–ä¸ºæ•°å­—
        if(!son[p][u]) son[p][u] = ++idx;   //è¯¥èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ›å»ºèŠ‚ç‚¹
        p = son[p][u];  //ä½¿â€œpæŒ‡é’ˆâ€æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    }
    cnt[p]++;  //ç»“æŸæ—¶çš„æ ‡è®°ï¼Œä¹Ÿæ˜¯è®°å½•ä»¥æ­¤èŠ‚ç‚¹ç»“æŸçš„å­—ç¬¦ä¸²ä¸ªæ•°
}

int query(string& s)
{
    int p = 0;
    for(int i = 0; i < s.size(); i++)
    {
        int u = s[i] - 'a';
        if(!son[p][u]) return 0;  //è¯¥èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œå³è¯¥å­—ç¬¦ä¸²ä¸å­˜åœ¨
        p = son[p][u]; 
    }
    return cnt[p];  //è¿”å›å­—ç¬¦ä¸²å‡ºç°çš„æ¬¡æ•°
}

int query1(string& s)
{
    int p = 0, ans = 0;
    for(int i = 0; i < s.size(); i++)
    {
        int u = s[i] - 'a';
        if(!son[p][u]) break;  //è¯¥èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œå³è¯¥å­—ç¬¦ä¸²ä¸å­˜åœ¨
        p = son[p][u];
        ans += cnt[p]; 
    }
    return ans;  //è¿”å›è¯¥å­—ç¬¦ä¸²çš„å‰ç¼€å‡ºç°çš„æ¬¡æ•°
}

signed main(){
    int n, m;
    cin >> n >> m;
    string s;
    for(int i = 1; i <= n; i++){
        cin >> s;
        insert(s);
    }
    for(int i = 1; i <= m; i++){
        cin >> s;
        cout << query1(s) << endl;
    }
    return 0;
}
```

## 1.5 STè¡¨

```cpp
#include<bits/stdc++.h>
const int MAXN=5e5+10;
using namespace std;

int n;
//stmax[i][j]è¡¨ç¤ºï¼Œä»iå¼€å§‹æ•°2^jä¸ªæ•°ï¼Œé‡Œé¢æœ€å¤§çš„æ•°ï¼Œ stminç›¸åŒ, log2[i]è¡¨ç¤ºlogä»¥2ä¸ºåº•içš„å€¼å–æ•´
int arr[MAXN],LOG2[MAXN],stmax[MAXN][19],stmin[MAXN][19];

void build(){
    LOG2[0] = -1;
    for(int i = 1;i <= n; i++){
        LOG2[i] = LOG2[i>>1]+1;
        stmax[i][0] = arr[i];
        stmin[i][0] = arr[i];
    }
    for(int p = 1; p <= LOG2[n]; p++){
        for(int i=1; i+(1<<p)-1 <= n; i++){
            stmax[i][p] = max(stmax[i][p-1], stmax[i + (1<<p-1)][p-1]);
            stmin[i][p] = min(stmin[i][p-1], stmin[i + (1<<p-1)][p-1]);
        }
    }
}

//æ±‚åŒºé—´æœ€å€¼
int query(int l,int r){
    int p=LOG2[r-l+1];
    int a=max(stmax[l][p],stmax[r-(1<<p)+1][p]);//åŒºé—´æœ€å¤§å€¼
    // int b=min(stmin[l][p],stmin[r-(1<<p)+1][p]);//åŒºé—´æœ€å°å€¼
    return a;//æˆ–è€…return b;
}
signed main(){
    int n;
    cin>>n;
    for(int i=1; i<=n; i++) cin>>arr[i];
    build();
    return 0;
}
```

## 1.6 åŒºé—´gcd

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define double long double
#define endl "\n"
#define PII pair<int, int>
#define x first
#define y second
const int N = 5e5 + 10;
const int M = 64;
const int mod = 998244353;
using PI3 = array<int, 3>;

// åŒºé—´gcdå®šç†
// ä»¤b[i] = a[i] - a[i - 1], i >= 2
// gcd(a[l], a[l+1],..., a[r]) = gcd(a[l], b[l + 1],..., b[r]);
int n, m;
int a[N],  b[N];

struct node{
    int l, r;
    int sum; // å·®åˆ†ç»´æŠ¤a[i]
    int g; // ç»´æŠ¤b[i]çš„åŒºé—´gcd
}tree[N << 2]; 

void pushup(int u){
    tree[u].sum = tree[u << 1].sum + tree[u << 1 | 1].sum;
    tree[u].g = gcd(tree[u << 1].g, tree[u << 1 | 1].g);
}

void build(int u, int l, int r){
    if(l == r) tree[u] = {l, r, b[l], b[l]};
    else{
        tree[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

void update(int u, int x, int d){
    if(tree[u].l == x && tree[u].r == x){
        tree[u].sum += d;
        tree[u].g += d;
    }
    else{
        int mid = tree[u].l + tree[u].r >> 1;
        if(x <= mid) update(u << 1, x, d);
        if(mid < x) update(u << 1 | 1, x, d);
        pushup(u);
    }
}

// è¿˜å¯ä»¥ç›´æ¥queryè¿”å›node
int query_gcd(int u, int l, int r){
    if(l <= tree[u].l && tree[u].r <= r) return tree[u].g;
    else{
        int mid = tree[u].l + tree[u].r >> 1;
        int g = 0;
        if(l <= mid) g = gcd(g, query_gcd(u << 1, l, r));
        if(mid < r) g = gcd(g, query_gcd(u << 1 | 1, l, r));
        return g;
    }
}

int query_sum(int u, int l, int r){
    if(l <= tree[u].l && tree[u].r <= r) return tree[u].sum;
    else{
        int mid = tree[u].l + tree[u].r >> 1;
        int sum = 0;
        if(l <= mid) sum += query_sum(u << 1, l, r);
        if(mid < r) sum += query_sum(u << 1 | 1, l, r);
        return sum;
    }
}

void solve(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
        b[i] = a[i] - a[i - 1];
    }

    build(1, 1, n);
    for(int i = 1; i <= m; i++){
        char op; int l, r, d;
        cin >> op;
        if(op == 'C'){ // åŒºé—´ä¿®æ”¹
            cin >> l >> r >> d;
            update(1, l, d);
            if(r + 1 <= n) update(1, r + 1, -d);
        }
        else{ // åŒºé—´æŸ¥è¯¢
            cin >> l >> r;
            if(l == r) cout << query_sum(1, 1, l) << endl;
            else{
                cout << gcd(query_sum(1, 1, l), query_gcd(1, l + 1, r)) << endl;
            }
        }
    }
}

signed main(){
    int T = 1;
    // cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```

## 1.7 æ‰«æçº¿

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define double long double
#define endl "\n"
#define PII pair<int, int>
#define x first
#define y second
const int N = 1e5 + 10;
const int M = 64;
const int mod = 998244353;
using PI3 = array<int, 3>;

int n;
// æ±‚çŸ©å½¢é¢ç§¯å¹¶
// ä»¥å‚ç›´çº¿æ‰«æxè½´, çº¿æ®µæ ‘ç»´æŠ¤yè½´çš„é•¿åº¦
struct Segment{
    double x, y1, y2;
    int op;
    bool operator < (const Segment &t) const {
        return x < t.x;
    }
}seg[N << 1];

struct node{
    int l, r; // æ¯ä¸ªç‚¹ä»£è¡¨çš„æ˜¯ys[i]~ys[i + 1]çš„ä¸€æ®µçº¿æ®µ
    int cnt;
    double len;
}tree[N << 3]; 

vector<double>ys;

int get(double y1){ // ç¦»æ•£åŒ–
    return lower_bound(ys.begin(), ys.end(), y1) - ys.begin();
}

void pushup(int u){ // åªæŸ¥è¯¢æ ¹èŠ‚ç‚¹ä¿¡æ¯å’Œpushupçš„å†™æ³•å¯¼è‡´ä¸éœ€è¦æ‡’æ ‡è®°
    if(tree[u].cnt) tree[u].len = ys[tree[u].r + 1] - ys[tree[u].l];
    else if(tree[u].l != tree[u].r){
        tree[u].len = tree[u << 1].len + tree[u << 1 | 1].len;
    }
    else tree[u].len = 0;
}

void build(int u, int l, int r){
    if(l == r) tree[u] = {l, r, 0, 0};
    else{
        tree[u] = {l, r, 0, 0};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

void update(int u, int l, int r, int d){
    if(l <= tree[u].l && tree[u].r <= r){
        tree[u].cnt += d;
        pushup(u);
    }
    else{
        int mid = tree[u].l + tree[u].r >> 1;
        if(l <= mid) update(u << 1, l, r, d);
        if(mid < r) update(u << 1 | 1, l, r, d);
        pushup(u);
    }
}


void solve(int t){
    ys.clear();
    
    for(int i = 1; i <= n; i++){
        double x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;
        seg[2 * i - 1] = {x1, y1, y2, 1};
        seg[2 * i] = {x2, y1, y2, -1};
        ys.push_back(y1), ys.push_back(y2);
    }   

    sort(ys.begin(), ys.end());
    ys.erase(unique(ys.begin(), ys.end()), ys.end());
    build(1, 0, ys.size() - 2);

    sort(seg + 1, seg + 2 * n + 1);
    double ans = 0;
    for(int i = 1; i <= 2 * n; i++){
        if(i > 1){
            ans += tree[1].len * (seg[i].x - seg[i - 1].x);
        }
        update(1, get(seg[i].y1), get(seg[i].y2) - 1, seg[i].op);
    }
    cout << "Test case #" << t << endl;
    cout << "Total explored area: ";
    cout << fixed << setprecision(2) << ans << endl << endl;
}

signed main(){
    int T = 0;
    // cin >> T;
    while(cin >> n && n){
        solve(++T);
    }
    return 0;
}
```



<div style="page-break-after: always;"></div>

# 2 æ‚ç±»

## 2.0 å¤´æ–‡ä»¶

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define _USE_MATH_DEFINES 
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<vector>
#include<set>
#include<map>
#include<stack>
#include<queue>
#include<unordered_map>
#include<unordered_set>
#include<bitset>
#include<ctime>
#include<random>
#include<array>
#include<list>
#include<iomanip>
#include<fstream>
#include<ostream>
#include<sstream>
#define PI M_PI
#define read(a) {char c;while((c=getchar())>47) a=a*10+(c^48);}
using i64 = long long;
using i128 = __int128_t;
using namespace std;

typedef long long LL;
typedef pair<LL, LL> PLL;
typedef pair<int, int> PII;
typedef unsigned long long ULL;
typedef pair<ULL, ULL> PUU;
typedef pair<double, double> PDD;

//äº¤äº’é¢˜è®°å¾—æ³¨é‡Šæ‰
#define endl "\n"
#define double long double
#define big_heap(T) priority_queue<T>
#define small_heap(T) priority_queue<T, vector<T>, greater<>>
#define PI M_PI
#define F1 first
#define F2 second
#define read(a) {char c;while((c=getchar())>47) a=a*10+(c^48);}
const int MAXN = 2e6 + 10;
const int N = 2e5 + 10;
const int M = 2e5 + 10;
const double EXP = 1e-8;
const int mod = 998244353;
const int INF = 0x3f3f3f3f;
const LL LNF = 0x3f3f3f3f3f3f3f3f;
void IOS(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
}
```

## 2.1 å¯¹æ‹

### 2.1.1checker.cpp

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int T = 100;

void IOS(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
}

int randint(int min, int max){
    static random_device rd;
    static mt19937 gen(rd());
    uniform_int_distribution<long long>dis(min, max);
    return dis(gen);
}

void DATA(){
    FILE *fp = fopen("F.in", "w");
    int n = randint(1, 10), q = randint(1, 10);
    fprintf(fp, "%d %d\n", n, q);
    for(int i = 1; i <= n; i++){
        int x = randint(1, 10);
        fprintf(fp, "%d ", x);
    }
    fclose(fp);
}

signed main(){
    for(int i = 1; i <= 1e5; i++){
        DATA();
        system("bf.exe < F.in > bf.out");
        system("std.exe < F.in > std.out");
        if(system("fc bf.out std.out 1>nul")){
            printf("WA at test %d\n", i);
            system("pause");
        }
        printf("AC!\n");
    }
    return 0;
}
```

## 2.2 äºŒåˆ†

```cpp
#include<iostream>
using namespace std;
int l,r;
//åˆ¤æ–­æ˜¯å¦æ»¡è¶³æ¡ä»¶
bool check(int mid){

}
int main(){
    int ans=0;
    //å¾€å·¦ä¾§æ‰¾
    while(l<=r){
        int mid=l+r>>1;
        if(check(mid)){
            ans=mid;
            r=mid-1;
        }
        else l=mid+1;
    }
    //å¾€å³ä¾§æ‰¾
    while(l<=r){
        int mid=l+r>>1;
        if(check(mid)){
            ans=mid;
            l=mid+1;
        }
        else r=mid-1;

    }
    cout<<ans;
}
```

## 2.3 éšæœºæ•°

```cpp
int randint(int min, int max) {//å¼ºå¤§çš„éšæœºæ•°ç”Ÿæˆå™¨ï¼Œéœ€è¦å¤´æ–‡ä»¶#include<random>
    static random_device rd;  // ç”¨äºç”Ÿæˆç§å­
    static mt19937 gen(rd()); // ä½¿ç”¨ Mersenne Twister ç”Ÿæˆå™¨
    uniform_int_distribution<long long> dis(min, max);
    return dis(gen);
}
```

## 2.4 ksmåŠå¿«è¯»å¿«å†™

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MOD 998244353

// é¢„å¤„ç†1~nçš„é€†å…ƒ
// inv[1] = 1;
// for(int i = 2;i <= n;i++)  inv[i] = (mod -  mod / i) * inv[mod % i] % mod;

long long fasterpower(long long base,long long power){
    long long result=1;
    while(power){
        if(power&1){
        result=result*base%MOD;
        }
        power>>=1;
        base=base*base%MOD;
    }
    return result;
}

inline void print(__int128_t n){
    if(n<0) cout << -1, n *= (-1);
    if(n>9) print(n/10);
    int num = n%10;
    cout << num;
}

__int128_t read(){
    __int128_t x = 0;
    int f = 1;
    char ch = getchar();
    if(ch == '-') f = -1, ch = getchar();
    while(ch >= '0' && ch <= '9'){
        x = x*10 + ch - '0';
        ch = getchar();
    }
    return x*f;
}

__int128_t ksm(__int128_t base, __int128_t power){
    __int128_t ans=1;
    while(power){
        if(power&1) ans*=base;
        power>>=1;
        base*=base;
    }
    return ans;
}

//æ±‚é€†å…ƒ, ç”¨è´¹é©¬å°å®šç†, a^(p-1) â‰¡ 1 (mod p)
//ä½¿ç”¨æ¡ä»¶ pä¸ºè´¨æ•°, gcd(a, p) = 1, 
//é‚£ä¹ˆ açš„é€†ç­‰äº a^(p-2)

signed main(){
    __int128_t x = read();
    print(x);
    return 0;
}
```

## 2.5 Lambdaå‡½æ•°

```cpp
/*
[capture](parameters) -> return_type {
    // å‡½æ•°ä½“
};

captureï¼šæ•è·åˆ—è¡¨ï¼Œç”¨äºæ•è·å¤–éƒ¨å˜é‡ã€‚å¯ä»¥æ˜¯=ï¼ˆæŒ‰å€¼æ•è·æ‰€æœ‰å¤–éƒ¨å˜é‡ï¼‰ã€&ï¼ˆæŒ‰å¼•ç”¨æ•è·æ‰€æœ‰å¤–éƒ¨å˜é‡ï¼‰ï¼Œæˆ–è€…æŒ‡å®šå…·ä½“çš„å˜é‡ã€‚
parametersï¼šå‚æ•°åˆ—è¡¨ï¼Œä¸æ™®é€šå‡½æ•°çš„å‚æ•°åˆ—è¡¨ç±»ä¼¼ã€‚
return_typeï¼šè¿”å›ç±»å‹ï¼Œå¯ä»¥çœç•¥ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æ¨å¯¼ã€‚
å‡½æ•°ä½“ï¼šLambdaå‡½æ•°çš„å®ç°ä»£ç ã€‚

eg1:
// å®šä¹‰ä¸€ä¸ªLambdaå‡½æ•°ï¼Œæ¥å—ä¸¤ä¸ªintå‚æ•°ï¼Œè¿”å›å®ƒä»¬çš„å’Œ
auto add = [](int a, int b) -> int {
    return a + b;
};

int result = add(3, 4);  // è°ƒç”¨Lambdaå‡½æ•°
std::cout << "Result: " << result << std::endl;  // è¾“å‡º: Result: 7
```

## 2.6 STL

```cpp
#include<bits/stdc++.h>
#include<iomanip>
#define PII pair<int, int>
using namespace std;
// cout<<setiosflags(ios::fixed)<<setprecision(n+i)<<PI<<endl;ä¿ç•™å°æ•°ç‚¹åå‡ ä½è¾“å‡º
//cout<<fixed<<setprecision(i)<<endl;
// string::npos
// (1LL << i), ä½è¿ç®—çš„æ—¶å€™åŠ¡å¿…è¦ç”¨lLLæˆ–è€…1ll, ä¸ç„¶ä¼šçˆ†int
// fprintf(fp, "%s\n", s.c_str()); cè¯­è¨€è¾“å‡ºstringè¦ç”¨stringå†…ç½®å‡½æ•°c_str()

// Lambdaå‡½æ•°
function<void(ll)> dfs = [&](ll u) -> void {
    if (vis.count(u)) return;
    vis.insert(u);
    for (ll v : adj[u]) dfs(v);
};

// ä½¿ç”¨ä»¿å‡½æ•°æ’åº
struct cmp{
    bool operator() (const PII&x, const PII&y)const{
        return (x.F2 == y.F2 ? x.F1 > y.F1 : x.F2 > y.F2);
    }  
};
set<PII, cmp>st;

//stringstreamç”¨æ³•
std::string str = "one two three four";
std::stringstream ss(str);
std::string word;
while (ss >> word) {
    std::cout << word << std::endl;
}

// vector a(n, 0); nä¸ªå…ƒç´ , åˆå§‹å€¼ä¸º0
// åˆå§‹åŒ–vectorçš„è¡Œåˆ—
vector prea(n+1, vector<int>(32)), preb = prea, pre = prea;
//è®¾ç½®è¡Œæ•°
vector<vector<int>>a;
a.resize(n);
//vectorå»é‡
sort(a.begin(), a.end());
a.erase(unique(a.begin(), a.end()), a.end());

// ä¸‰è§’å‡½æ•°sin(), åä¸‰è§’å‡½æ•°asin()
```

## 2.7 å…¨æ’åˆ—å‡½æ•°

```cpp
#include<bits/stdc++.h>
using namespace std;

signed main(){
    int n;
    vector<int> a(n + 1);
    for(int i = 1; i <= n; i++) cin >> a[i];
    sort(a.begin(), a.end());//å…¨æ’åˆ—å‡½æ•°å¿…è¦æ¡ä»¶

    do{
        //å†…å®¹
    }while(next_permutation(a.begin(), a.end()));
    return 0;
}
```

## 2.8 å‰ç¼€å’Œå·®åˆ†

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1e4+10;

int diff[MAXN][MAXN];//äºŒç»´å·®åˆ†æ•°ç»„
int maxn=0;
void solve(){
    int x1,y1,x2,y2;
    cin>>x1>>y1>>x2>>y2;
    x1+=2;y1+=2;x2++;y2++;
    maxn=max(max(max(x1,x2),max(y1,y2)),maxn);
    //åŒºé—´ä¿®æ”¹
    diff[x1][y1]++;
    diff[x1][y2+1]--;
    diff[x2+1][y1]--;
    diff[x2+1][y2+1]++;
}

signed main(){
    int T,cnt=0;
    cin>>T;
    for(int i=0;i<T;i++)solve();
    // cout<<maxn<<endl;
    for(int i=1;i<=maxn;i++){
        for(int j=1;j<=maxn;j++){
            diff[i][j]+=diff[i][j-1]+diff[i-1][j]-diff[i-1][j-1];//äºŒç»´å‰ç¼€å’Œ
            // cout<<diff[i][j]<<" ";
            if(diff[i][j])cnt++;
        }
    }
    cout<<cnt<<endl;
    return 0;
}
```

## 2.9 è®°å¿†åŒ–æœç´¢

```cpp
#include<bits/stdc++.h>
#define int long long
const int MAXN=1e5+10;
using namespace std;

int F[MAXN];
int  Fibonacci(int n){
    if(F[n]) return F[n];
    else return F[n]=Fibonacci(n-1)+Fibonacci(n-2);//ç­‰å¼çš„è¿”å›å€¼æ˜¯å·¦å€¼

}

//ç»„åˆæ’ç­‰å¼ï¼šCm n=Cm n-1+Cm-1 n-1;
int res[100010][100010];
int C(int n,int m){
    if(m==0||m==n) return res[n][m]=1;
    if(res[n][m]) return res[n][m];
    return res[n][m] = C(n-1,m)+C(n-1,m-1);
}

signed main() {
    F[1]=F[2]=1;
    Fibonacci(1e2);
    for(int i=1;i<=92;i++) cout<<F[i]<<endl;
    return 0; 
} 
```

## 2.10 æ’åº

```cpp
//å‡åº
int partition(int a[], int s, int t){
    int i=s, j=t;
    int base=a[s];
    while(i<j){
        while(i<j && a[j]>=base ) j--;
        if(i<j){
            a[i]=a[j];
            i++;
        }
        while(i<j && a[i]<=base) i++;
        if(i<j){
            a[j]=a[i];
            j--;
        }
    }
    a[i]=base;
    return i;
}

void quicksort(int a[], int s, int t){
    if(s<t){
        int mid=partition(a, s, t);
        quicksort(a, s, mid-1);
        quicksort(a, mid+1, t);
    }
}

void selectsort(int a[], int n){
    for(int i=0; i<n-1; i++){
        int k=i;
        for(int j=i+1; j<n; j++){
            if(a[j]<a[k]) k=j;
        }
        swap(a[i], a[k]);
    }
}

void heapify(int a[], int i, int size){
    int l=2*i+1;
    while(l < size){
        int best = l+1 < size &&a[l+1] > a[l] ? l+1 : l;
        best = a[best] > a[i] ? best : i;
        if(best == i){
            break;
        }
        swap(a[i], a[best]);
        i=best;
        l=2*i+1;
    }
}

void HeapSort(int a[], int n){
    for(int i=n/2; i>=0; i--){
        heapify(a, i, n);
    }
    for(int i=n; i>=2; i--){
        swap(a[0], a[i-1]);
        heapify(a, 0, i-1);
    }
}

void ShellSort(int a[], int n){
    for(int d=n/2; d>=1; d--){
        for(int i=d; i<n; i++){
            int temp=a[i];
            int j;
            for(j=i-d; j>=0 && temp<a[j]; j-=d) a[j+d]=a[j];
            a[j+d]=temp;
        }
    }
}

typedef long long ll;
template<typename T>
void Merge(vector<T>&arr,vector<T>&temparr,ll low,ll mid,ll high){
    ll a=low;
    ll b=mid+1;
    ll p=low;
    while(a<=mid&&b<=high){
        if(arr[a]<arr[b]){
            temparr[p++]=arr[a++];
        }
        else{
            temparr[p++]=arr[b++];

        }
    }
    while(a<=mid){
        temparr[p++]=arr[a++];
    }
    while(b<=high){
        temparr[p++]=arr[b++];
    }

    while (low <= high) {
		arr[low] = temparr[low];
		low++;
	}
}
template<typename T>
void MergeSort(vector<T>&arr,vector<T>&temparr,ll low ,ll high){
    if(low<high){
        ll mid=(low+high)/2;
        MergeSort(arr,temparr,low,mid);
        MergeSort(arr,temparr,mid+1,high);
        Merge(arr,temparr,low,mid,high);
    }
}
```

## 2.11 bitset

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
 * =========================================
 * C++ bitset ç”¨æ³•å…¨é›†æ¨¡æ¿ï¼ˆæ³¨é‡Šç‰ˆï¼‰ï¼Œå¯ä¼˜åŒ–å¸¸æ•°1/64
 * =========================================
*/

const int N = 1024;   // bitset å¤§å°å¿…é¡»æ˜¯ã€ç¼–è¯‘æœŸå¸¸é‡ã€‘

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    /* =========================
     * ä¸€ã€å®šä¹‰ä¸åˆå§‹åŒ–
     * ========================= */

    bitset<N> a;                  // é»˜è®¤å…¨ 0
    bitset<N> b(5);               // ç”¨æ•´æ•°åˆå§‹åŒ–ï¼ˆäºŒè¿›åˆ¶å½¢å¼å­˜å…¥ï¼‰
    bitset<N> c("10101");         // ç”¨å­—ç¬¦ä¸²åˆå§‹åŒ–ï¼ˆå³è¾¹æ˜¯ä½ä½ï¼‰

    /* =========================
     * äºŒã€å•ç‚¹è®¿é—®ä¸ä¿®æ”¹
     * ========================= */

    a[i];                         // è®¿é—®ç¬¬ i ä½ï¼ˆ0-basedï¼‰
    a.test(i);                    // å®‰å…¨è®¿é—®ï¼ˆè¿”å› boolï¼‰

    a.set(i);                     // ç¬¬ i ä½è®¾ä¸º 1
    a.reset(i);                   // ç¬¬ i ä½è®¾ä¸º 0
    a.flip(i);                    // ç¬¬ i ä½å–å

    a.set(i, 1);                  // æŒ‡å®šèµ‹å€¼ä¸º 1
    a.set(i, 0);                  // æŒ‡å®šèµ‹å€¼ä¸º 0

    /* =========================
     * ä¸‰ã€æ•´ä½“æ“ä½œ
     * ========================= */

    a.set();                      // æ‰€æœ‰ä½è®¾ä¸º 1
    a.reset();                    // æ‰€æœ‰ä½è®¾ä¸º 0
    a.flip();                     // æ‰€æœ‰ä½å–å

    /* =========================
     * å››ã€ä½è¿ç®—ï¼ˆæ ¸å¿ƒèƒ½åŠ›ï¼‰
     * ========================= */

    bitset<N> x, y, z;

    z = x & y;                    // æŒ‰ä½ä¸
    z = x | y;                    // æŒ‰ä½æˆ–
    z = x ^ y;                    // æŒ‰ä½å¼‚æˆ–
    z = ~x;                       // æŒ‰ä½å–å

    /* =========================
     * äº”ã€ä½ç§»æ“ä½œï¼ˆéå¾ªç¯ï¼‰
     * ========================= */

    z = x << 3;                   // å·¦ç§» 3 ä½ï¼Œä½ä½è¡¥ 0ï¼Œé«˜ä½æº¢å‡ºä¸¢å¼ƒ
    z = x >> 2;                   // å³ç§» 2 ä½ï¼Œé«˜ä½è¡¥ 0ï¼Œä½ä½ä¸¢å¼ƒ

    /* =========================
     * å…­ã€ç»Ÿè®¡ä¸çŠ¶æ€åˆ¤æ–­
     * ========================= */

    x.count();                    // ç»Ÿè®¡ 1 çš„ä¸ªæ•°
    x.any();                      // æ˜¯å¦å­˜åœ¨è‡³å°‘ä¸€ä¸ª 1
    x.none();                     // æ˜¯å¦å…¨ä¸º 0
    x.all();                      // æ˜¯å¦å…¨ä¸º 1

    /* =========================
     * ä¸ƒã€è½¬æ¢
     * ========================= */

    bitset<32> num;

    num.to_ulong();               // è½¬ unsigned longï¼ˆä½æ•°ä¸èƒ½è¶…ï¼‰
    num.to_ullong();              // è½¬ unsigned long long

    num.to_string();              // è½¬ stringï¼ˆé«˜ä½â†’ä½ä½ï¼‰

    /* =========================
     * å…«ã€éå†æ‰€æœ‰ä¸º 1 çš„ä½ç½®ï¼ˆGNU æ‰©å±•ï¼Œé«˜æ•ˆï¼‰
     * ========================= */

    // ä»ç¬¬ä¸€ä¸ªä¸º 1 çš„ä½å¼€å§‹æ‰¾
    for (int i = a._Find_first(); i < N; i = a._Find_next(i)) {
        // i ä¸ºä¸€ä¸ªå€¼ä¸º 1 çš„ä½ç½®
    }

    /* =========================
     * ä¹ã€bitset ä¼˜åŒ– DPï¼ˆå­é›†å’Œæ¨¡å‹ï¼‰
     * ========================= */

    /*
     * dp[s] = æ˜¯å¦èƒ½å‡‘å‡ºå’Œ s
     * çŠ¶æ€è½¬ç§»ï¼šdp |= dp << w
     */

    const int MAXS = 10000;
    bitset<MAXS + 1> dp;

    dp[0] = 1;                    // åˆå§‹çŠ¶æ€

    vector<int> w = {3, 5, 7};
    for (int v : w) {
        dp |= (dp << v);          // å­é›†å’Œè½¬ç§»
    }

    /* =========================
     * åã€bitset ä¼˜åŒ–å›¾è®ºï¼ˆä¼ é€’é—­åŒ… / Floydï¼‰
     * ========================= */

    /*
     * reach[i][j] = i æ˜¯å¦èƒ½åˆ°è¾¾ j
     * Floyd æ ¸å¿ƒï¼š
     * if (reach[i][k]) reach[i] |= reach[k];
     */

    const int V = 500;
    bitset<V> reach[V];

    // åŠ è¾¹ç¤ºä¾‹ï¼šu -> v
    int u = 1, v = 2;
    reach[u][v] = 1;

    for (int k = 0; k < V; k++) {
        for (int i = 0; i < V; i++) {
            if (reach[i][k]) {
                reach[i] |= reach[k];   // bitset æ‰¹é‡å¹¶é›†
            }
        }
    }

    /* =========================
     * åä¸€ã€å¸¸è§ç”¨é€”æ€»ç»“
     * ========================= */

    /*
     * 1) å­é›† DP
     *    dp |= dp << w
     *
     * 2) å›¾å¯è¾¾æ€§
     *    reach[i] |= reach[k]
     *
     * 3) çŠ¶æ€å‹ç¼©
     *    bitset è¡¨ç¤ºé›†åˆ
     *
     * 4) å¿«é€Ÿäº¤é›†ç»Ÿè®¡
     *    (a & b).count()
     *
     * 5) å¿«é€Ÿå¹¶é›†
     *    a |= b
     */

    return 0;
}

```



<div style="page-break-after: always;"></div>

# 3 å­—ç¬¦ä¸²

## 3.1 KMP1

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
const int N = 1e6 + 10;

string s, t;
int n, m, ne[N];

void kmp(){
    for(int i = 2, j = 0; i <= m; i++){
        while(j && t[i] != t[j + 1]) j = ne[j];
        if(t[i] == t[j + 1]) j++;
        ne[i] = j;
    }

    for(int i = 1, j = 0; i <= n; i++){
        while(j && s[i] != t[j + 1]) j = ne[j];
        if(s[i] == t[j + 1]) j++;
        if(j == m){
            cout << i - j + 1 << endl;
            j = ne[j];
        }
    }
}

void solve(){
    cin >> s >> t;
    n = s.size(), m = t.size();
    s = " " + s;
    t = " " + t;
    kmp();
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 3.2 KMP2

```cpp
#include<iostream>
const int MAXN=1e5+10;
using namespace std;
void getNext(string t,int next[]){//iæ˜¯åç¼€æœ«å°¾,jæ˜¯å‰ç¼€æœ«å°¾ï¼Œä¹Ÿä»£è¡¨æœ€é•¿ç›¸ç­‰å‰åç¼€çš„é•¿åº¦
    int j=0,k=-1;
    next[0]=-1;
    while(j<t.size()-1){
        if(k==-1||t[j]==t[k]){
            j++,k++;
            next[j]=k;
        }
        else k=next[k];
    }

}

void getNextval(string t,int nextval[]){
    int j=0,k=-1;
    nextval[0]=-1;
    while(j<t.size()-1){
        if(k==-1||t[j]==t[k]){
            j++,k++;
            if(t[j]!=t[k]) nextval[j]=k;
            else nextval[j]=nextval[k];
        }
        else k=nextval[k];
    }
}

int KMP(string s,string t){
    int nextval[MAXN],i=0,j=0;
    getNextval(t,nextval);
    while(i<s.size()&&j<t.size()){
        if(j==-1||s[i]==t[j]){
            i++,j++;
        }
        else j=nextval[j];
    }
    if(j>=t.size())return i-t.size();
    else return -1;
}

int a[MAXN],nextval[MAXN];
int main(){
    string S="aabcabC8dab";
    string t="abcaabbabcab";
    getNext(t,a);
    getNextval(t,nextval);
    for(int i=0;i<=11;i++){
        cout<<a[i]<<" ";
    }
    cout<<endl;
    for(int i=0;i<=11;i++){
        cout<<nextval[i]<<" ";
    }
    return 0;
}
```

## 3.3 å›æ–‡ä¸²ä¸ªæ•°

```cpp
#include<iostream>
using namespace std;
int count;
    int expand(string s,int left,int right){
        int cnt=0;
        while(left>=0&&right<s.size()&&s[left]==s[right]){
            left--;
            right++;
            cnt++;
        }
        return cnt;
    }
    int countSubstrings(string s) {
        count=0;
        for(int i=0;i<s.size();i++){
            count+=expand(s,i,i);
            count+=expand(s,i,i+1);
        }
        return count;
    }
```

## 3.4 å­—ç¬¦ä¸²å“ˆå¸Œ

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int unsigned long long
#define double long double
#define endl "\n"
#define PII pair<int, int>
#define x first
#define y second
const int N = 3e2 + 10;
const int M = 6e4 + 10;
// å•æ¨¡å“ˆå¸Œ, På–131æˆ–è€…13331, æ¨¡æ•°ä¸º2^64(è¦æ±‚Pä¸æ¨¡æ•°äº’è´¨), unsigned long longè‡ªç„¶æº¢å‡º
const int P = 131; 
const int mod = 998244353;

void IOS(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
}

int n, q, m, K;
int fac[M];
string s[N], sq[N];
int hs[N][M], ht[N][M];

// é¢„å¤„ç†Pçš„å¹‚
void init(){
    fac[0] = 1;
    for(int i = 1; i <= m; i++){
        fac[i] = fac[i - 1] * P;
    }
}

// è®¡ç®—åŒºé—´å­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼
int cal1(int i, int l, int r){
    return hs[i][r] - hs[i][l - 1] * fac[r - l + 1];
}

int cal2(int i, int l, int r){
    return ht[i][r] - ht[i][l - 1] * fac[r - l + 1];
}


void solve(){
    cin >> n >> q >> m >> K;
    init();
    for(int i = 1; i <= n; i++){
        cin >> s[i];
        s[i] = " " + s[i];
        hs[i][0] = 0;
        for(int j = 1; j <= m; j++){
            // å­—ç¬¦ä¸²å“ˆå¸Œ
            hs[i][j] = hs[i][j - 1] * P + (s[i][j] - 'a');
        }
    }   

    for(int i = 1; i <= q; i++){
        cin >> sq[i];
        sq[i] = " " + sq[i];
        ht[i][0] = 0;
        for(int j = 1; j <= m; j++){
            ht[i][j] = ht[i][j - 1] * P + (sq[i][j] - 'a');
        }

        int ans = 0;

        for(int j = 1; j <= n; j++){
            int lst = 0, diff = 0;        
            for(int k = 1; k <= K + 1; k++){
                int l = lst + 1, r = m;
                int tar = m + 1;
                while(l <= r){
                    int mid = (l + r) / 2;
                    if(cal1(j, lst + 1, mid) != cal2(i, lst + 1, mid)){
                        tar = mid;
                        r = mid - 1;
                    }
                    else l = mid + 1;
                }
                
                if(tar > m){
                    break;
                }
                diff++;
                lst = tar;
            }
            if(diff <= K){
                ans++;
                // cout << s[j] << endl;
            } 
        }

        cout << ans << endl;
    }
}

signed main(){
    IOS();
    int T = 1;
    
    // cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```


<div style="page-break-after: always;"></div>

# 4 æœç´¢ä¸å›¾è®º

## 4.1 Dijkstra

```cpp
// trick:è™šæ‹Ÿæºç‚¹
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e3+10;
int head[MAXN];//head[i]è¡¨ç¤ºä»¥iä¸ºèµ·ç‚¹çš„ç¬¬ä¸€æ¡è¾¹çš„è¾¹å·
int n,en,s;//nä¸ªç‚¹ï¼Œeæ¡è¾¹ï¼ŒsåŸç‚¹
int dis[MAXN];//ç‚¹åˆ°æºç‚¹çš„è·ç¦»
int check[MAXN];//æ ‡è®°ä¸€ä¸ªç‚¹içš„dis[i]å·²è¾¾æœ€ä¼˜
priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>>heap;

struct Edge{
    int next;//ä¸‹ä¸€æ¡è¾¹çš„è¾¹å·
    int to;//è¿™æ¡è¾¹çš„ç»ˆç‚¹
    int w;//è¾¹çš„æƒå€¼
}e[MAXN];

int cnt;//è¾¹çš„æ¡æ•°
void add(int u,int v,int w){//ç±»ä¼¼å¤´æ’æ³•
    cnt++;
    e[cnt].next=head[u];
    e[cnt].to=v;
    e[cnt].w=w;
    head[u]=cnt;
}

signed main(){
    cin>>n>>en;
    memset(dis,0x3f,sizeof dis);
    for(int i=1;i<=en;i++){
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);
        add(b, a, c);
    }
    cin>>s;
    dis[s]=0;
    heap.push({dis[s],s});
    while(!heap.empty()){
        auto [minn,minx]=heap.top();
        heap.pop();
        if(check[minx])continue;//å»é‡
        check[minx]=1;
        for(int h=head[minx];h;h=e[h].next){
            int k=e[h].to;
            if(minn+e[h].w<dis[k]){
                dis[k]=minn+e[h].w;
                heap.push({dis[k],k});
            }
        }
    }
    return 0;
}
```

## 4.2 åˆ†å±‚å›¾æœ€çŸ­è·¯

```cpp
// æ´›è°·P4568 [JLOI2011] é£è¡Œè·¯çº¿
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN=1e4+10;
const int N=4e5+10;

int n, m, k, s, t;
struct node{
    int to;
    int next;
    int w;
}e[2*N];

int dis[MAXN][20];
int head[MAXN];
bool visited[MAXN][20];
int cnt;

void add(int u, int v, int w){
    cnt++;
    e[cnt].to=v;
    e[cnt].w=w;
    e[cnt].next=head[u];
    head[u]=cnt;
}

priority_queue<PLL, vector<PLL>, greater<>>heap;

void dijstra(int p){
    dis[s][p]=0;
    heap.push({0, s});
    while(!heap.empty()){
        int x = heap.top().second;
        heap.pop();
        if(visited[x][p]) continue;
        visited[x][p] = 1;
        for(int i=head[x]; i; i=e[i].next){
            int x1=e[i].to, w1=e[i].w;
            if(dis[x][p] + w1 < dis[x1][p] || p && dis[x][p-1]< dis[x1][p]){
                dis[x1][p]=dis[x][p] + w1;
                if(p) dis[x1][p]=min(dis[x1][p], dis[x][p-1]);
                heap.push({dis[x1][p], x1});
            }

        }
    }
}

void solve(){
    cin>>n>>m>>k>>s>>t;
    for(int i=0; i<m; i++){
        int u ,v, w;
        cin>>u>>v>>w;
        add(u ,v, w);
        add(v, u, w);
    }
    memset(dis, 0x3f, sizeof(dis));
    for(int i=0; i<=k; i++) dijstra(i);
    cout<< dis[t][k] <<endl;
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 4.3 Floyd

```cpp
#include<iostream>
using namespace std;
const int inf = 0x7fffff - 1;
int e[10][10];
int n, m;

int main() {
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (i == j)e[i][j] = 0;
			else e[i][j] = inf;
		}
	}
	int src, dst, val;
	for (int i = 0; i < m; i++) {
		cin >> src >> dst >> val;
		e[src][dst] = val;
	}

	//Floyd-Warshallç®—æ³•æ ¸å¿ƒè¯­å¥
	for (int k = 0; k < n; k++) {
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (e[i][k] + e[k][j] < e[i][j]) {
					e[i][j] = e[i][k] + e[k][j];
				}
			}
		}
	}

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			printf("%5d", e[i][j]);
		}
		cout << endl;
	}
	return 0;
}
```

## 4.4 Kruskal

```cpp
//é€‚ç”¨äºç¨€ç–å›¾
#include<bits/stdc++.h>
using namespace std;
struct edge{ //ç›´æ¥å­˜è¾¹ 
	int u,v,w;
};
edge edges[200010];
int parent[5010];
 
int find(int x) //å¹¶æŸ¥é›†(æŸ¥æ‰¾ç¥–å…ˆ) 
{
	while(x!=parent[x])
	    parent[x]=find(parent[x]);
	return parent[x];
}
 
bool cmp(edge obj1,edge obj2) //å¯¹è¾¹æƒè¿›è¡Œæ’åº 
{
	return obj1.w<obj2.w;
}
 
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;i++) 
		cin>>edges[i].u>>edges[i].v>>edges[i].w;
	for(int i=1;i<=n;i++)
		parent[i]=i;
	sort(edges+1,edges+1+m,cmp); //å¯¹è¾¹è¿›è¡Œæ’åº 
	long long ans=0,cnt=0; //ansè¡¨ç¤ºç­”æ¡ˆï¼Œcntè¡¨ç¤ºå·²ç»æœ‰å¤šå°‘æ¡è¾¹è¢«åŠ è¿›æ¥äº† 
	for(int i=1;i<=m;i++) //éå†æ‰€æœ‰è¾¹ 
	{
		if(find(edges[i].u)!=find(edges[i].v)) //å¦‚æœå…¬å…±ç¥–å…ˆä¸åŒï¼Œé‚£ä¹ˆå°±ç®—ä¸åŒçš„è¿é€šå— 
		{
			ans+=edges[i].w; //ç­”æ¡ˆæ›´æ–° 
			parent[find(edges[i].u)]=find(edges[i].v); //æŠŠæ–°çš„ç‚¹åŠ å…¥è¿é€šå—ä¸­ 
			cnt++; //è¾¹æ•°+1 
		}
	}
	if(cnt<n-1) 
		cout<<"orz"; //nä¸ªç‚¹è¦æœ‰n-1æ¡è¾¹ï¼Œå°‘äºn-1æ¡è¾¹è¯´æ˜ä¼šæœ‰å­¤ç«‹çš„ç‚¹ 
	else 
		cout<<ans;
	return 0;
}
```

## 4.5 Prim

```cpp
//é€‚ç”¨äºç¨ å¯†å›¾
#include<bits/stdc++.h>
using namespace std;
const int N=5010,INF=1e8+10;
int g[N][N];//é‚»æ¥çŸ©é˜µ
int dist[N];//è®°å½•æ¯ä¸ªèŠ‚ç‚¹åˆ°å½“å‰ç”Ÿæˆæ ‘çš„æœ€çŸ­è·ç¦»
int st[N];//æ ‡è®°æ¯ä¸ªèŠ‚ç‚¹æ˜¯å¦å·²è¢«åŠ å…¥åˆ°ç”Ÿæˆæ ‘ä¸­
int n,m;
 
long long prim() //æœ´ç´ çš„primç®—æ³• 
{
	long long ans=0; //è®°å½•ç­”æ¡ˆ 
	for(int i=0;i<n;i++)
	{
		int t=-1;  
		for(int j=1;j<=n;j++)
		{
			if(st[j]==0&&(t==-1||dist[j]<dist[t])) //æŠŠè·ç¦»æœ€å°çš„ä¸”ä¸åœ¨è¿é€šå—çš„ç‚¹åŠ è¿›æ¥ 
				t=j;
		}
		
		st[t]=1; //æ ‡è®°è¿™ä¸ªç‚¹å·²ç»è¢«åŠ å…¥è‡³è¿é€šå—ä¸­ 
		
		if(i!=0&&dist[t]==INF) 
			return INF; 	//å¦‚æœä¸æ˜¯æœ€å¼€å§‹çš„æƒ…å†µå¹¶ä¸”æœ€çŸ­è·ç¦»æ˜¯æ­£æ— ç©·ï¼Œè¯´æ˜æ˜¯ä¸è¿é€šçš„(æœ€å¼€å§‹çš„æ—¶å€™dist[t]ä¸€å®šæ˜¯æ­£æ— ç©·ï¼Œå¯ä»¥ç®€å•ç†è§£ä¸ºæœ€å°ç”Ÿæˆæ ‘çš„"æ ¹") 
		if(i!=0) 
			ans+=dist[t]; //åªè¦ä¸æ˜¯æœ€å¼€å§‹çš„æƒ…å†µ(æ ‘çš„æ ¹)ï¼Œå°±æŠŠæœ€çŸ­è¾¹çš„é•¿åº¦åŠ å…¥ç­”æ¡ˆä¸­ 
		for(int j=1;j<=n;j++) 
			dist[j]=min(dist[j],g[t][j]); //æ›´æ–°å„ä¸ªç‚¹åˆ°è¿é€šå—çš„æœ€å°è·ç¦» 
	}
	return ans;
}
 
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++) //åˆå§‹åŒ–æ“ä½œ 
	{
		dist[i]=INF;
		for(int j=1;j<=n;j++)
			g[i][j]=INF;
	}
	
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		if(x==y) 
			continue; //å»æ‰è‡ªç¯
		//å¯¹äºé‡è¾¹ï¼Œå–æœ€å°å€¼å³å¯ 
		g[x][y]=min(g[x][y],z); 
		g[y][x]=min(g[y][x],z);
	}
	
	long long t=prim();
	
	if(t==INF) 
		cout<<"orz"; //è¡¨ç¤ºå­˜åœ¨ä¸è¿é€šçš„æƒ…å†µ 
	else 
		cout<<t;
	return 0;
}
```

## 4.6 SPFA

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define double long double
#define endl "\n"
#define PII pair<int, int>
#define x first
#define y second
const int N = 5e2 + 10;
const int M = 64;
const int mod = 998244353;
using PI3 = array<int, 3>;

void IOS(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
}

vector<PII>g[N];
int n, m1, m2;
bool st[N];
int dis[N], cnt[N];

// å¦‚æœå­˜åœ¨è´Ÿç¯ï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›false
bool spfa(){
    memset(dis, 0x3f, sizeof dis);
    memset(st, 0, sizeof st);
    memset(cnt, 0, sizeof cnt);
    queue<int>que; // æœ‰ç¯æ—¶å¯ä»¥ç”¨stackä¼˜åŒ–
    que.push(0);
    dis[0] = 0, st[0] = 1;

    while(que.size()){
        auto u = que.front();
        que.pop();
        st[u] = 0;
        for(auto [w, v] : g[u]){
            if(dis[u] + w >= dis[v]) continue;
            dis[v] = dis[u] + w;
            cnt[v] = cnt[u] + 1;
            if(cnt[v] >= n) return true; // è·¯å¾„æœ‰nä¸ªç‚¹ï¼ˆä¸åŒ…æ‹¬èµ·ç‚¹ï¼‰è¯´æ˜æœ‰ç¯å¹¶ä¸”æ˜¯è´Ÿç¯
            if(!st[v]){
                que.push(v);
                st[v] = 1;
            }
        }
    }
    return false;
}

void solve(){
    cin >> n >> m1 >> m2;
    for(int i = 1; i <= n; i++) g[i].clear();
    for(int i = 1; i <= m1; i++){
        int u, v, w; cin >> u >> v >> w;
        g[u].push_back({w, v});
        g[v].push_back({w, u});
    }    
    for(int i = 1; i <= m2; i++){
        int u, v, w; cin >> u >> v >> w;
        g[u].push_back({-w, v});
    } 
    
    for(int i = 1; i <= n; i++){
        g[0].push_back({0, i});
    }
    if(spfa()) cout << "YES" << endl;
    cout << "NO" << endl;
    
}

signed main(){
    IOS();
    int T = 1;
    cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```

## 4.7 æ‹“æ‰‘æ’åº

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5 + 10;
const int M = 2e5 + 10;

int n, m;
int ans[N], in[N];
vector<int>v[N];

void solve(){
    cin >> n >> m;
    for(int i = 1; i <= m; i++){
        int x, y;
        cin >> x >> y;
        //åˆå§‹åŒ–
        in[y]++;
        v[x].push_back(y);
    }
    queue<int>que;
    for(int i = 1; i <= n; i++){
        // ç°å°†0åº¦å…¥é˜Ÿ
        if(in[i] == 0) que.push(i);
    }
    int cnt = 0;
    // å¼€å§‹æ’åº
    while(que.size()){
        if(que.size() == 1){
            int t = que.front();
            que.pop();
            ans[t] = ++cnt;
            for(auto i : v[t]){
                if(--in[i] == 0) que.push(i);
            }
        }
        else{
            cout << "No\n";
            return ;
        }
    }
    cout << "Yes\n";
    for(int i = 1; i <= n; i++){
        cout << ans[i] << " \n"[i == n];
    }
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 4.8 ä¸‰ç±»å¹¶æŸ¥é›†

```cpp
#include<iostream>
using namespace std;
int father[100010];
int n;

struct DSU {
    std::vector<int> f, siz;
    
    DSU() {}
    DSU(int n) {
        init(n);
    }
    
    void init(int n) {
        f.resize(n);
        std::iota(f.begin(), f.end(), 0);
        siz.assign(n, 1);
    }
    
    int find(int x) {
        while (x != f[x]) {
            x = f[x] = f[f[x]];
        }
        return x;
    }
    
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }
    
    //æ±‚ç¥–å®—ç»“ç‚¹æ‰€åœ¨è¿é€šå—çš„ç‚¹æ•°
    int size(int x) {
        return siz[find(x)];
    }
};


// å¸¦æƒå¹¶æŸ¥é›†
int w[N];// è®¾w[u] = a[u] - a[fa[u]];

struct DSU{
    vector<int>fa;
    DSU(int n = 0){
        fa.resize(n);
        iota(fa.begin(), fa.end(), 0);
    }
    
    int find(int u){
        if(u == fa[u]) return u;
        int f = fa[u];
        int nxt = find(f);
        w[u] += w[f];
        return fa[u] = nxt;
    }
    
    int same(int u, int v){
        return find(u) == find(v);
    }
    
    bool merge(int u, int v, int k){
        int fu = find(u), fv = find(v);
        if(fu == fv) return false;
        w[fu] = k - w[u] + w[v];
        fa[fu] = fv;
        return true;
    }
};
```

## 4.9 æ ‘çš„ç›´å¾„

```cpp
//P4408 [NOI2003] é€ƒå­¦çš„å°å­©
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN=2e6+10;
const int N=2e5+10;
int n, m;

struct edge{
    int to;
    int next;
    int w;
}e[2*N];

int head[N], dis1[N], dis2[N];
int cnt;

void add(int u, int v, int w){
    cnt++;
    e[cnt].to=v;
    e[cnt].w=w;
    e[cnt].next=head[u];
    head[u]=cnt;
}

int maxdis,beginv;
void dfs1(int u ,int fa, int dis){//æ±‚ç¬¬ä¸€ä¸ªç«¯ç‚¹
    if(dis > maxdis){
        maxdis=dis;
        beginv=u;
    }
    for(int i=head[u]; i; i=e[i].next){
        int v=e[i].to, w=e[i].w;
        if(v == fa) continue;
        dfs1(v, u, dis+w);
    }
}

int endv;

void dfs2(int u, int fa, int dis){//æ±‚ç¬¬äºŒä¸ªç«¯ç‚¹, é¡ºä¾¿æ±‚å…¶ä»–ç‚¹åˆ°ç¬¬ä¸€ä¸ªç«¯ç‚¹è·ç¦»
    dis1[u]=dis;
    if(dis > maxdis){
        maxdis=dis;
        endv=u;
    }
    for(int i=head[u]; i; i=e[i].next){
        int v=e[i].to, w=e[i].w;
        if(v == fa) continue;
        dfs2(v, u, dis+w);
    }
}
//dfs2æ±‚å®Œä¹‹å, maxdiså³ä¸ºæ•°çš„ç›´å¾„

void dfs3(int u, int fa, int dis){//æ±‚å…¶ä»–ç‚¹åˆ°ç¬¬äºŒä¸ªç«¯ç‚¹è·ç¦»
    dis2[u]=dis;
    for(int i=head[u]; i; i=e[i].next){
        int v=e[i].to, w=e[i].w;
        if(v == fa) continue;
        dfs3(v, u, dis+w);
    }
}

void solve(){
    cin>>n>>m;
    for(int i=0; i<m; i++){
        int u, v, w;
        cin>>u>>v>>w;
        add(u, v, w);
        add(v, u, w);
    }
    dfs1(1, 0, 0);
    maxdis=0;
    dfs2(beginv, 0, 0);
    dfs3(endv, 0, 0);
    int res=0;
    for(int i=1; i<=n; i++){
        res=max(res, min(dis1[i], dis2[i]));
    }

    cout<<res+maxdis<<endl;
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 4.10 æœ€è¿‘å…¬å…±ç¥–å…ˆ
```cpp
#include<bits/stdc++.h>
const int N = 5e5 + 10;
const int STEP = 20;
using namespace std;

vector<int>g[N];
int n, m, root;
int depth[N], fa[N][STEP];

void dfs(int u, int father){
    depth[u] = depth[father] + 1;
    fa[u][0] = father;
    for(int i = 1; (1 << i) <= depth[u]; i++){
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    }
    for(auto v : g[u]){
        if(v == father) continue;
        dfs(v, u);
    }
}

int lca(int x, int y){
    if(depth[x] < depth[y]) swap(x, y);
    for(int i = STEP - 1; i >= 0; i--){
        if((depth[x] - depth[y]) & (1 << i)) x = fa[x][i];
    }

    if(x == y) return x;
    for(int i = STEP - 1; i >= 0; i--){
        if(fa[x][i] != fa[y][i]){
            x = fa[x][i], y = fa[y][i];
        }
    }

    return fa[x][0];
}

void solve(){
    cin >> n >> m >> root;
    for(int i = 1; i < n; i++){
        int x, y; cin >> x >> y;
        g[x].push_back(y);
        g[y].push_back(x);
    }
    dfs(root, -1);
    while(m--){
        int a, b; cin >> a >> b;
        cout << lca(a, b) << endl;
    }
}

signed main(){
    int T = 1;
    // cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```

## 4.11 SCC(å¼ºè¿é€šåˆ†é‡)

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
#define int long long
#define endl "\n"
const int N = 2e5 + 10;

vector<int>g[N];
int dfn[N], low[N], tot;// æ—¶é—´æˆ³dfn[i]è¡¨ç¤ºèŠ‚ç‚¹iç¬¬ä¸€æ¬¡è¢«è®¿é—®çš„é¡ºåº, low[i] è¡¨ç¤ºä»èŠ‚ç‚¹iå‡ºå‘èƒ½è®¿é—®çš„æœ€æ—©æ—¶é—´æˆ³
int stk[N], instk[N], top;// stk[]æ¨¡æ‹Ÿæ ˆ, instk[i]è¡¨ç¤ºèŠ‚ç‚¹iåœ¨æ ˆä¸­
int scc[N], siz[N], cnt;// scc[i]è¡¨ç¤ºèŠ‚ç‚¹içš„å¼ºè¿é€šåˆ†é‡çš„ç¼–å·, siz[i]è¡¨ç¤ºç¼–å·içš„sccåŒ…å«å¤šå°‘èŠ‚ç‚¹

//tarjan sccç¼©ç‚¹, ç¼©å®Œçš„ç‚¹åˆšå¥½æ˜¯æ‹“æ‰‘é€†åºçš„
void tarjan(int u){ // æ—¶é—´å¤æ‚åº¦O(n + m)
    dfn[u] = low[u] = ++tot;
    stk[++top] = u, instk[u] = 1;
    for(auto v : g[u]){
        if(dfn[v] == 0){// è‹¥væœªè®¿é—®
            tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(instk[v]){// è‹¥vå·²è®¿é—®å¹¶åœ¨æ ˆä¸­
            low[u] = min(low[u], dfn[v]);
        }
    }

    if(dfn[u] == low[u]){// è‹¥uæ˜¯sccçš„æ ¹
        int t; cnt++;
        do{
            t = stk[top--], instk[t] = 0;
            scc[t] = cnt, siz[cnt]++;
        }while(t != u);
    }
}

int n;
int din[N], dout[N];// din[i]è¡¨ç¤ºå…¥åº¦, doutè¡¨ç¤ºå‡ºåº¦

void solve(){
    cin >> n;
    for(int i = 1; i <= n; i++){
        int v;
        while(cin >> v, v){
            g[i].push_back(v);
        }
    }   
    
    for(int u = 1; u <= n; u++){
        if(dfn[u] == 0) tarjan(u);
    }
    
    for(int u = 1; u <= n; u++){
        for(auto v : g[u]){
            if(scc[u] != scc[v]){
                dout[scc[u]]++;
                din[scc[v]]++;
            }
        }
    }
    int cnt1 = 0, cnt2 = 0;
    for(int i = 1; i <= cnt; i++){
        if(din[i] == 0) cnt1++;
        if(dout[i] == 0) cnt2++;
    }
    cout << cnt1 << endl;
    if(cnt == 1) cout << 0 << endl;
    else cout << max(cnt1, cnt2) << endl;
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 4.12 IDDFS

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define endl "\n"
const int N = 1e3 + 10;

int n;
int s[100], m;

//å‰ªæä¹‹åæ—¶é—´å¤æ‚åº¦O(m^2 * 2^m)
bool dfs(int p, int sum){
    if(p == m) return sum == n;
    if(sum << m-p < n) return false;
    s[p] = sum;
    for(int i = 0; i <= p; i++){
        if(dfs(p + 1, sum - s[i]) || dfs(p + 1, sum + s[i])) return true;
    }
    return false;
}

void solve(){
    //æšä¸¾æ·±åº¦
    for(m = 0; !dfs(0, 1); m++);
    cout << m << endl;
}

signed main(){
    while(cin >> n && n){
        solve();
    }
    return 0;
}
```

## 4.13 åŒå‘bfs

```cpp
// acwing 190.å­—ç¬¦å˜æ¢
#include <bits/stdc++.h>
using namespace std;
#define endl "\n"
const int N = 5e5 + 10;

int n;
string s0, sn;
unordered_map<string, int>da;
unordered_map<string, int>db;
vector<string>a, b;

int extend(queue<string>& que, unordered_map<string, int>& da, unordered_map<string, int>& db, vector<string>& a, vector<string>& b){
    string s = que.front();
    que.pop();
    for(int i = 0; i < n; i++){
        int l1 = a[i].size();
        for(int j = 0; j <= (int)s.size() - l1; j++){
            if(s.substr(j, l1) == a[i]){
                string t = s;
                t.replace(j, l1, b[i]);
                if(da.count(t)) continue;
                da[t] = da[s] + 1;
                if(db.count(t)) return da[t] + db[t];
                que.push(t);
            }
        }
    }

    return 11;
}

int bfs(){
    if(s0 == sn) return 0;
    queue<string>q1;
    queue<string>q2;
    q1.push(s0), da[s0] = 0;
    q2.push(sn), db[sn] = 0;
    while(q1.size() && q2.size()){
        int d;
        if(q1.size() < q2.size()) d = extend(q1, da, db, a, b);
        else d = extend(q2, db, da, b, a);
        if(d < 11) return d;
    }

    return 11;
}

void solve(){   
    cin >> s0 >> sn;
    string t1, t2;
    while(cin >> t1 >> t2){
        a.push_back(t1);
        b.push_back(t2);
    }
    n = a.size();

    int ans = bfs();
    if(ans < 11) cout << ans << endl;
    else cout << "NO ANSWER!" << endl;
}

signed main(){
    int T = 1;
    // cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```

## 4.14 Astar

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
typedef pair<int, int> PII;
#define endl "\n"
const int N = 1e3 + 10;
const int LNF = 0x3f3f3f3f3f3f3f3f;
using PIII = array<int, 3>;

int n, m;
int s, t, k;
vector<PII>g1[N];
vector<PII>g2[N];
int st[N];
int dis[N];// æ‰€æœ‰ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·ç¦», é¢„ä¼°å‡½æ•°

void dijstra(){
    memset(dis, 0x3f, sizeof dis);
    priority_queue<PII, vector<PII>, greater<>>heap;
    dis[t] = 0;
    heap.push({0, t});
    while(heap.size()){
        auto [min_w, u] = heap.top();
        heap.pop();
        if(st[u]) continue;
        st[u] = true;
        for(auto [v, w] : g2[u]){
            if(dis[u] + w < dis[v]){
                dis[v] = dis[u] + w;
                heap.push({dis[v], v});
            }
        }
    }
}

int Astar(){
    priority_queue<PIII, vector<PIII>, greater<>>heap;
    memset(st, 0, sizeof st);
    heap.push({dis[s], 0, s});
    int cnt = 0;
    while(heap.size()){
        auto [min_w, w, u] = heap.top();
        heap.pop();
        if(st[u] >= k) continue;
        st[u]++;
        if(st[u] == k && u == t) return w;
        for(auto [v, w1] : g1[u]){
            if(st[v] < k)
            heap.push({dis[v] + w + w1, w + w1, v}); // çœŸå®è·ç¦» + é¢„ä¼°è·ç¦» = è¯„ä»·å€¼
        }
    }
    return -1;
}

void solve(){
    cin >> n >> m;
    for(int i = 1; i <= m; i++){
        int u, v, w; cin >> u >> v >> w;
        g1[u].push_back({v, w});
        g2[v].push_back({u, w});
    }   

    cin >> s >> t >> k;
    dijstra();
    if(s == t) k++;
    cout << Astar() << endl;
}

signed main(){
    int T = 1;
    // cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```

## 4.15 ç¯çš„å¤§å°

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl "\n"
const int N = 2e5 + 10;
using namespace std;

int n, m;
vector<int>g[N];
int st[N];

void dfs(int u, int begin, int cnt){
    for(auto v : g[u]){
        if(st[v]){
            continue;
        }
        if(v == begin){
            // æ­¤æ—¶cntå³ä¸ºç¯çš„å¤§å°
            // 
        }
        st[v] = 1;
        dfs(v, begin, cnt + 1);
        // st[v] = 0;
    }
}

void solve(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++) g[i].clear(), st[i] = 0;
    for(int i = 1; i <= m; i++){
        int u, v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
}

signed main(){
	int T = 1;
	cin >> T;
	while(T--){
		solve();
	}
}
```

## 4.16 åŒå‘dfs

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
const int N = 46 + 10;

int n, m;
int a[N];
int ans = 0;
vector<int>p;

int find(int x){
    int l = 0, r = (int)p.size() - 1;
    int res = 0;
    while(l <= r){
        int mid = l + r >> 1;
        if(x + p[mid] <= m){
            res = p[mid];
            l = mid + 1;
        }
        else r = mid - 1;
    }
    return x + res;
}

// å­˜å‰n/2çš„dfsçš„æ‰€æœ‰å¯èƒ½å€¼
void dfs1(int u, int s){
    if(s > m) return ;
    if(u > n / 2){
        p.push_back(s);
        return ;
    }
    dfs1(u + 1, s + a[u]);
    dfs1(u + 1, s);
}

// åˆ©ç”¨ç¬¬ä¸€éƒ¨åˆ†çš„å€¼æ¥äºŒåˆ†
void dfs2(int u, int s){
    if(s > m) return ;
    ans = max(ans, find(s));
    if(u > n) return ;
    dfs2(u + 1, s + a[u]);
    dfs2(u + 1, s);
}

void solve(){
    cin >> m >> n;    
    for(int i = 1; i <= n; i++) cin >> a[i];
    sort(a + 1, a + n + 1, greater());
    dfs1(1, 0);
    sort(p.begin(), p.end());
    p.erase(unique(p.begin(), p.end()), p.end());
    dfs2(n / 2 + 1, 0);
    cout << ans << endl;
}

signed main(){
    int T = 1;
    // cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```

## 4.17 IDAstar

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"

int n;
int a[16];
int p[5][16];

int get(){ // é¢„ä¼°å‡½æ•°
    int cnt = 0;
    for(int i = 1; i < n; i++){
        if(a[i + 1] != a[i] + 1) cnt++;
    }
    return (cnt + 2) / 3;
}

bool dfs(int dep, int max_dep){
    if(dep + get() > max_dep) return false;
    if(get() == 0) return true;
    memcpy(p[dep], a, sizeof a);
    for(int len = 1; len <= n; len++){
        for(int i = 1; i + len - 1 <= n; i++){
            for(int k = 1; k < i; k++){
                for(int l = i - 1; l >= k; l--) a[l + len] = a[l];
                for(int l = k; l <= k + len - 1; l++) a[l] = p[dep][l - k + i];
                if(dfs(dep + 1, max_dep)) return true;
                memcpy(a, p[dep], sizeof a);
            }
        }
    }
    return false;
}

void solve(){
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 0; i < 5; i++){
        if(dfs(0, i)){
            cout << i << endl;
            return ;
        }
    }
    cout << "5 or more" << endl;
}

signed main(){
    int T = 1;
    cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```

## 4.18 dfså‰ªæ

```cpp
// stick æ³•ï¼ˆé€æ ¹æ‹¼æ£å­ï¼‰
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
const int N = 64 + 10;

int n, ans, tar, zu;
int a[N], b[N];
bool st[N];

// dfs(start, u, s)
// start : ä»å“ªæ ¹æœ¨æ£’å¼€å§‹å°è¯•ï¼ˆä¸‹æ ‡ï¼‰
// u     : å·²ç»æ‹¼å¥½çš„æ£å­æ•°é‡
// s     : å½“å‰è¿™æ ¹æ£å­å·²ç»æ‹¼å‡ºçš„é•¿åº¦
// è¿”å›å€¼: æ˜¯å¦èƒ½æˆåŠŸæ‹¼å®Œæ‰€æœ‰æ£å­
bool dfs(int start, int u, int s) {
    // å¦‚æœå·²ç»æ‹¼å¥½äº† zu æ ¹æ£å­ï¼ˆæ€»æ•°ï¼‰ï¼Œè¯´æ˜æˆåŠŸ
    if (u == zu) return true;

    // å¦‚æœå½“å‰è¿™æ ¹æ£å­åˆšå¥½æ‹¼æ»¡ tar é•¿åº¦
    // é‚£ä¹ˆé€’å½’å»æ‹¼ä¸‹ä¸€æ ¹æ£å­ï¼ˆé•¿åº¦ä» 0 å¼€å§‹ï¼‰
    if (s == tar) return dfs(0, u + 1, 0);

    // ä» start å¼€å§‹æšä¸¾å‰©ä½™çš„æœ¨æ£’
    for (int i = start; i <= n; i++) {
        if (st[i]) continue;             // æœ¨æ£’å·²ç”¨è¿‡ï¼Œè·³è¿‡
        if (s + a[i] > tar) continue;    // è¶…è¿‡ç›®æ ‡é•¿åº¦ï¼Œè·³è¿‡

        st[i] = true;                    // æ ‡è®°å½“å‰æœ¨æ£’å·²ç”¨
        if (dfs(i + 1, u, s + a[i])) return true; // å°è¯•æ”¾å…¥å½“å‰æ£å­
        st[i] = false;                   // å›æº¯

        // -------- å‰ªæéƒ¨åˆ† --------
        if (s == 0) return false;        // å¦‚æœè¿™æ ¹æ£å­çš„ç¬¬ä¸€ä¸ªæœ¨æ£’æ”¾ä¸è¿›å»ï¼Œç›´æ¥å¤±è´¥ï¼ˆé¿å…å¯¹ç§°ï¼‰
        if (s + a[i] == tar) return false; // å¦‚æœæ”¾è¿›å»åˆšå¥½å¡«æ»¡ä½†å¤±è´¥äº†ï¼Œä¹Ÿç›´æ¥å¤±è´¥
        // åŒå±‚å»é‡ï¼šå¦‚æœæœ‰å¤šæ ¹æœ¨æ£’é•¿åº¦ç›¸åŒï¼Œåªå°è¯•ä¸€æ¬¡ï¼Œé¿å…é‡å¤æœç´¢
        int j = i;
        while (j <= n && a[j] == a[i]) j++;
        i = j - 1;
    }
    return false; // æ‰€æœ‰å°è¯•éƒ½å¤±è´¥
}

void solve(){
    int sum = 0;
    for(int i = 1; i <= n; i++) cin >> a[i], sum += a[i], b[i] = st[i] = 0;
    sort(a + 1, a + n + 1, greater());
    ans = sum;
    for(int i = n; i >= 1; i--){
        if(sum % i) continue;
        tar = sum / i, zu = i;
        if(dfs(1, 0, 0)){
            ans = tar;
            break;
        }
    }
    cout << ans << endl;
}

signed main(){
    int T = 1;
    while(cin >> n && n){
        solve();
    }
    return 0;
}
```

## 4.19 ksmä¼˜åŒ–æœ€çŸ­è·¯

```cpp
//s->tæ°å¥½ç»è¿‡kæ¡è¾¹çš„æœ€çŸ­è·¯
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
const int N = 2e2 + 10;
const int M = 2e5 + 10;

int n, p, m, s, t;
int dis[N][N], ans[N][N];
int temp[N][N];
map<int, int>mp; //ç¦»æ•£åŒ–æ¯ä¸ªç‚¹

void mul(int c[][N], int a[][N], int b[][N]){
    for(int i = 1; i <= n; i++){
        fill(temp[i], temp[i] + n + 1, 1e18);
    }

    for(int k = 1; k <= n; k++){
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= n; j++){
                temp[i][j] = min(temp[i][j], a[i][k] + b[k][j]);
            }
        }
    }

    memcpy(c, temp, sizeof temp);
}

void ksm(){ //å€å¢
    for(int i = 1; i <= n; i++){
        fill(ans[i], ans[i] + n + 1, 1e18);
        ans[i][i] = 0; //åˆå§‹ç»è¿‡0æ¡è¾¹
    }
    
    while(p){
        if(p&1) mul(ans, ans, dis); // ans = ans * dis;
        mul(dis, dis, dis); // dis = dis * dis;
        p >>= 1;
    }
}

void solve(){
    cin >> p >> m >> s >> t;
    for(int i = 1; i <= 2 * m; i++){
        fill(dis[i], dis[i] + 2 * m + 1, 1e18);
    }

    for(int i = 1; i <= m; i++){
        int u, v, w; cin >> w >> u >> v;
        if(!mp.count(u)) mp[u] = ++n;
        if(!mp.count(v)) mp[v] = ++n;
        u = mp[u], v = mp[v];
        dis[u][v] = dis[v][u] = min(dis[u][v], w);
    }

    s = mp[s], t = mp[t];

    ksm();
    cout << ans[s][t] << endl;
}

signed main(){
    IOS();
    int T = 1;
    // cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```

## 4.20 æœ€å°ç¯ï¼ˆfloydï¼‰

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
const int N = 1e2 + 10;
const int M = 2e5 + 10;

int n, m;
int dis[N][N], d[N][N];
int mid[N][N];
vector<int>path;

void get_path(int i, int j){
    int k = mid[i][j];
    if(k == 0) return ;
    get_path(i, k);
    path.push_back(k);
    get_path(k, j);
}

void solve(){
    cin >> n >> m;   
    for(int i = 1; i <= n; i++){
        fill(dis[i], dis[i] + n + 1, 1e18);
    }

    for(int i = 1; i <= m; i++){
        int u, v, w; cin >> u >> v >> w;
        dis[v][u] = dis[u][v] = min(dis[u][v], w);
    }
    
    memcpy(d, dis, sizeof d); //å­˜åŸå§‹è¾¹é•¿
    int ans = 1e18;
    for(int k = 1; k <= n; k++){
        for(int i = 1; i < k; i++){ //æšä¸¾ç¯ä¸Šçš„ä¸‰ä¸ªç‚¹i,k,j
            for(int j = i + 1; j < k; j++){
                if(dis[i][j] + d[j][k] + d[k][i] < ans){
                    ans = dis[i][j] + d[j][k] + d[k][i];
                    path = {j, k, i};
                    get_path(i, j);
                }
            }
        }

        for(int i = 1; i <= n; i++){ //è®¡ç®—æœ€çŸ­è·¯å’Œæ±‚ä¸­é—´ç‚¹
            for(int j = 1; j <= n; j++){
                if(dis[i][k] + dis[k][j] < dis[i][j]){
                    dis[i][j] = dis[i][k] + dis[k][j];
                    mid[i][j] = k; 
                }
    
            }
        }
    }

    if(ans > 1e18/2) cout << "No solution." << endl;
    else{
        for(auto x : path) cout << x << " ";
        cout << endl;
    }

}

signed main(){
    IOS();
    int T = 1;
    // cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```

## 4.21 æœ€å°ç¯ï¼ˆdfsï¼‰

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
typedef pair<int, int> PII;
#define endl "\n"
#define x first
#define y second
const int N = 1e2 + 10;
const int M = 2e5 + 10;

int n, m;
vector<PII>g[N];
int cnt[N], st[N];
vector<int>p;
int mi = 1e18;
vector<int>ans;

void dfs(int u, int fa){
    cnt[u]++;
    for(auto [w, v] : g[u]){
        if(v == fa) continue;
        if(cnt[v]) cnt[v]++;
        if(!cnt[v]){
            dfs(v, u);
        }
    }
}

void loop(int u, int fa, int sum){
    if(sum >= mi) return ;
    st[u] = 1;
    p.push_back(u);
    for(auto [w, v] : g[u]){
        if(v == fa) continue;
        if(st[v]){
            if(sum + w < mi){
                ans = p;
                mi = sum + w;
            }
        }
        else{
            loop(v, u, sum + w);
        }
    }
    st[u] = 0;
    p.pop_back();
}

void solve(){
    cin >> n >> m;  
    map<PII, int>mp;  
    for(int i = 1; i <= m; i++){
        int u, v, w; cin >> u >> v >> w;
        if(u > v) swap(u, v);
        if(mp.count({u, v})) mp[{u, v}] = min(mp[{u, v}], w);
        mp[{u, v}] = w;
    }
    
    for(auto x : mp){
        auto [u, v] = x.x;
        int w = x.y;
        g[u].push_back({w, v});
        g[v].push_back({w, u});
    }

    dfs(1, -1);

    for(int i = 1; i <= n; i++){
        if(cnt[i] > 1) loop(i, -1, 0);
    }

    if(ans.size() == 0) cout << "No solution." << endl;
    else{
        for(auto x : ans) cout << x << " ";
        cout << endl;
    }
}

signed main(){
    IOS();
    int T = 1;
    // cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```

## 4.22 eDCC(è¾¹åŒè¿é€šåˆ†é‡)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define double long double
#define endl "\n"
#define PII pair<int, int>
#define x first
#define y second
const int N = 5e4 + 10;
const int M = 1e4 + 10;
const int mod = 998244353;
using PI3 = array<int, 3>;

int n, m;
vector<PII>g[N];
int dfn[N], low[N], tot;
stack<int>stk;
int dcc[N], siz[N], cnt;
bool bri[M];

void tarjan(int u, int edge){
    dfn[u] = low[u] = ++tot;
    stk.push(u);
    for(auto [v, id] : g[u]){
        if(!dfn[v]){
            tarjan(v, id);
            low[u] = min(low[u], low[v]);
            if(low[v] > dfn[u]){ // u-vè¾¹ä¸ºå‰²è¾¹æˆ–æ¡¥
                bri[id] = bri[id^1] = 1;
            }
        }
        else if(id != (edge^1)){ // ä¸æ˜¯åå‘è¾¹
            low[u] = min(low[u], dfn[v]);
        }
    }

    if(dfn[u] == low[u]){
        int t = -1; cnt++;
        do{
            t = stk.top(), stk.pop();
            dcc[t] = cnt, siz[cnt]++; // è®°å½•edcc
        }while(t != u);
    }
}

int d[N];

void solve(){
    cin >> n >> m;
    for(int i = 0; i < m; i++){
        int u, v; cin >> u >> v;
        g[u].push_back({v, i*2});
        g[v].push_back({u, i*2 + 1});
    }

    for(int i = 1; i <= n; i++){
        if(!dfn[i]) tarjan(i, 0);
    }

    for(int u = 1; u <= n; u++){
        for(auto [v, id] : g[u]){
            if(dcc[u] != dcc[v]){
                d[dcc[u]]++, d[dcc[v]]++;
            }
        }
    }

    int ans = 0;
    for(int i = 1; i <= cnt; i++){
        if(d[i] <= 2) ans++;
    }
    
    if(cnt == 1) cout << 0 << endl;
    else cout << (ans + 1) / 2 << endl;
}

signed main(){
    IOS();
    int T = 1;
    // cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```

## 4.23 vDCC(ç‚¹åŒè¿é€šåˆ†é‡)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define double long double
#define endl "\n"
#define PII pair<int, int>
#define x first
#define y second
const int N = 2e3 + 10;
const int M = 64;
const int mod = 998244353;
using PI3 = array<int, 3>;
using ull = unsigned long long;

int n, m;
int dfn[N], low[N], tot;
stack<int>stk;
vector<int>dcc[N], g[N];
int cut[N], cnt;

void tarjan(int u, int root){
    dfn[u] = low[u] = ++tot;
    stk.push(u);
    if(!g[u].size()){ // å­¤ç«‹ç‚¹
        dcc[++cnt].push_back(u);
        return ;
    }

    int child = 0;
    for(auto v : g[u]){
        if(!dfn[v]){
            tarjan(v, root);
            low[u] = min(low[u], low[v]);
            if(low[v] >= dfn[u]){ 
                child++;
                // uä¸ºå‰²ç‚¹
                if(u != root || child > 1) cut[u] = 1; 

                int t = -1; ++cnt;
                do{ // è®°å½•vdccè¿é€šå—
                    t = stk.top(), stk.pop();
                    dcc[cnt].push_back(t);
                }while(t != v);
                dcc[cnt].push_back(u);
            }
            
        }
        else low[u] = min(low[u], dfn[v]);
    }
}

void solve(int T){
    n = cnt = tot = 0;
    for(int i = 1; i <= 1e3; i++){
        g[i].clear(), dcc[i].clear();
        cut[i] = dfn[i] = low[i] = 0;
    }
    for(int i = 1; i <= m; i++){
        int u, v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
        n = max({n, u, v});
    }

    for(int i = 1; i <= n; i++){
        if(!dfn[i]) tarjan(i, i);
    }

    ull need = 0, ans = 1;
    for(int i = 1; i <= cnt; i++){
        int num = 0;
        for(auto v : dcc[i]){
            if(cut[v]) num++;
        }
        if(num == 0){
            if(dcc[i].size() > 1) need += 2, ans *= dcc[i].size() * (dcc[i].size() - 1) / 2;
            else need++;
        } 
        else if(num == 1) need++, ans *= dcc[i].size() - 1;
    }
    cout << "Case " << T << ": " << need << " " << ans << endl;
}

signed main(){
    IOS();
    int T = 0;
    // cin >> T;
    while(cin >> m && m){
        solve(++T);
    }
    return 0;
}
```

## 4.24 åŒˆç‰™åˆ©ç®—æ³•

```cpp
// äºŒåˆ†å›¾ä¸­, æœ€å¤§åŒ¹é…æ•° = æœ€å°ç‚¹è¦†ç›–, æœ€å¤§ç‹¬ç«‹é›† = n - æœ€å¤§åŒ¹é…æ•° = æœ€å°è·¯å¾„è¦†ç›–
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define double long double
#define endl "\n"
#define PII pair<int, int>
#define x first
#define y second
const int N = 1e2 + 10;
const int M = 1e3;
const int mod = 998244353;
using PI3 = array<int, 3>;

int n, t;
int g[N][N], match[N][N];
bool vis[N][N];

int d[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

// ç”·å¥³ç›¸äº², ç”·é€‰å¥³, å¯å å¯è®©, è´ªå¿ƒåŒ¹é…
bool dfs(int x0, int y0){
    for(int i = 0; i < 4; i++){ // åªç”¨å•å‘è¾¹, ç”·->å¥³
        int x1 = x0 + d[i][0], y1 = y0 + d[i][1];
        if(x1 < 1 || x1 > n || y1 < 1 || y1 > n || g[x1][y1] || vis[x1][y1]) continue;
        vis[x1][y1] = 1; // æ ‡è®°å¦¹å­
        if(!match[x1][y1] || dfs(match[x1][y1] / M, match[x1][y1] % M)){
            match[x1][y1] = x0 * M + y0; // é…æˆå¯¹
            return true;
        }
    }
    return false;
}

void solve(){
    cin >> n >> t;
    for(int i = 1; i <= t; i++){
        int x, y; cin >> x >> y;
        g[x][y] = 1;
    }

    int ans = 0;
    // æ—¶é—´å¤æ‚åº¦O(n * m) 
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            memset(vis, 0, sizeof vis);
            if((i + j) % 2 == 0 && !g[i][j]){
                if(dfs(i, j)) ans++;
            }
        }
    }
    cout << ans << endl;
}

signed main(){
    IOS();
    int T = 1;
    // cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```

## 4.25 æ¬§æ‹‰å›è·¯(è·¯å¾„)

```cpp
// 1.æ— å‘å›¾, æ‰€æœ‰è¾¹è”é€š(å¯ä»¥ç”¨dfsåˆ¤è”é€š):
// æ¬§æ‹‰å›è·¯ï¼šåº¦æ•°ä¸ºå¥‡æ•°çš„ç‚¹ä¸ªæ•°ä¸º0
// æ¬§æ‹‰è·¯å¾„ï¼šåº¦æ•°ä¸ºå¥‡æ•°çš„ç‚¹ä¸ªæ•°ä¸º0æˆ–2
// 2.æœ‰å‘å›¾, æ‰€æœ‰è¾¹è”é€š:
// æ¬§æ‹‰å›è·¯ï¼šå…¥åº¦ä¸ç­‰äºå‡ºåº¦çš„ç‚¹ä¸ªæ•°ä¸º0
// æ¬§æ‹‰è·¯å¾„ï¼šå…¥åº¦ä¸ç­‰äºå‡ºåº¦çš„ç‚¹ä¸ªæ•°ä¸º0; æˆ–è€…2, è¦æ±‚å‡ºåº¦=å…¥åº¦+1çš„ç‚¹ä¸ºèµ·ç‚¹, å…¥åº¦=å‡ºåº¦+1çš„ç‚¹ä¸ºç»ˆç‚¹
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define double long double
#define endl "\n"
#define PII pair<int, int>
#define x first
#define y second
const int N = 1e5 + 10;
const int M = 2e5 + 10;
const int mod = 998244353;
using PI3 = array<int, 3>;

int t, n, m;
vector<PII>g[N];
bool st[2 * M];
int din[N], dout[N];
vector<int>ans; // æ±‚å‡ºæ¥çš„æ˜¯é€†åº

// ååºéå†, æ±‚æ¬§æ‹‰å›è·¯æˆ–è€…æ¬§æ‹‰è·¯å¾„çš„ç‚¹æˆ–è€…è¾¹
void dfs(int u){
    while(g[u].size()){
        auto &[id, v] = g[u].back();
        g[u].pop_back();
        if(st[id]) continue;
        if(t == 1){
            st[id] = st[id^1] = 1;
        }
        else{
            st[id] = 1;
        }

        dfs(v);
        if(t == 1){
            int op = 1;
            if(id&1) op = -1;
            ans.push_back((id/2 + 1) * op);
            st[id] = st[id^1] = 1;
        }
        else{
            ans.push_back(id);
            st[id] = 1;
        }
        
    }
}

void s1(){
    int root = 0;
    for(int i = 0; i < m; i++){
        int u, v; cin >> u >> v;
        g[u].push_back({2 * i, v});
        g[v].push_back({2 * i + 1, u});
        dout[u]++, din[v]++;
        root = u;
    }

    for(int i = 1; i <= n; i++){
        if(din[i] + dout[i] & 1){
            cout << "NO" << endl;
            return ;
        }
    }

    dfs(root);
    if(ans.size() != m){
        cout << "NO" << endl;
        return ;

    }

    cout << "YES" << endl;
    reverse(ans.begin(), ans.end());
    for(auto &x : ans) cout << x << " ";
}

void s2(){
    int root = 0;
    for(int i = 1; i <= m; i++){
        int u, v; cin >> u >> v;
        g[u].push_back({i, v});
        dout[u]++, din[v]++;
        root = u;
    }

    for(int i = 1; i <= n; i++){
        if(din[i] != dout[i]){
            cout << "NO" << endl;
            return ;
        }
    }

    dfs(root);
    if(ans.size() != m){
        cout << "NO" << endl;
        return ;

    }
    cout << "YES" << endl;
    reverse(ans.begin(), ans.end());
    for(auto &x : ans) cout << x << " ";
}

void solve(){
    cin >> t >> n >> m;
    if(t == 1) s1();
    else s2();

}

signed main(){
    IOS();
    int T = 1;
    // cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```



<div style="page-break-after: always;"></div>

# 5 æ•°è®º

## 5.1 é«˜ç²¾åº¦

```cpp
const int M = 50;
void add(int a[], int b[]){
    static int c[M];
    memset(c, 0, sizeof c);
    int t = 0;
    for(int i = 0; i < M; i++){
        t += a[i] + b[i];
        c[i] = t%10;
        t /= 10;
    }
    memcpy(a, c, sizeof c);
}

void mul(int a[], int b){
    static int c[M];
    memset(c, 0, sizeof c);
    int t = 0;
    for(int i = 0; i < M; i++){
        t += a[i] * b;
        c[i] = t % 10;
        t /= 10;
    }
    memcpy(a, c, sizeof c);
}

void add(vector<int>&A, vector<int>&B){
    int t = 0;
    int la = a.size(), lb = b.size();
    int i;
    for(i = 0; i < la || l < lb; i++){
        if(i < la) t += A[i];
        if(i < lb) t += B[i];
        A[i] = t % 10;
        t /= 10;
    }
    while(t){
        A[i++] = t % 10;
        t /= 10;
    }
}

//é«˜ç²¾åº¦ä¹˜ä½ç²¾åº¦
void mul(vector<int>&A, int b){
    int t = 0;
    for(int i = 0; i < A.size(); i++){
        t += A[i] * b;
        A[i] = t % 10;
        t /= 10;
    }
    while(t) A.push_back(t%10), t /= 10;

}
```

## 5.2 çº¿æ€§ç­›

```cpp
//è´¨æ•°éƒ½ç¬¦åˆ 6*n+1 æˆ–è€… 6*n-1
#include<iostream>
using namespace std;
const int N = 2e5;
int flag[N], prime[N], phi[N]; // phi[i]æ˜¯æ¬§æ‹‰å‡½æ•°(<=iä¸iäº’è´¨çš„ä¸ªæ•°)
int pnum;

void getPrime(){
    flag[1] = 1, phi[1] = 1;
    for(int i = 2; i < N; i++){
        if(!flag[i]){
            prime[++pnum] = i;
            phi[i] = i - 1;
        }
        for(int j = 1; j <= pnum && i * prime[j] < N; j++){
            flag[i * prime[j]] = 1;
            if(i % prime[j] == 0){
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        } 
    }
}

signed main(){
    double t0 = clock();
    getPrime();
    double t1 = clock();
    cout<<"ç”¨æ—¶:"<<(t1-t0)/1000<<"s\n";
    cout<<pnum<<endl;
    // for(int i=0;i<pnum;i++)cout<<prime[i]<<" ";
    // cout<<prime[pnum-1];
    return 0;
}
```

## 5.3 è£´èœ€å®šç†

```cpp
int x, y, a, b, c, d;

//è£´èœ€å®šç†
//a*m+b*n=y, a,b,yä¸ºå®šå€¼, æƒ³è¦æ‰¾åˆ°æ»¡è¶³æ–¹ç¨‹çš„ä¸€ç»„æ•´æ•°m, n, éœ€è¦ä½¿ yå¯ä»¥æ•´é™¤gcd(a, b)
void solve(){
    cin>>x>>y>>a>>b>>c>>d;
    int flag=1;
    if(x%gcd(d,c)) flag=0;
    if(y%gcd(a, b)) flag=0;
    if(flag) cout<<"YES\n";
    else cout<<"NO\n";

}
```

## 5.4 æ‰©å±•æ¬§å‡ é‡Œå¾—

```cpp
// a*x â‰¡ 1(mod b) ,xæ˜¯a åœ¨mod bæ„ä¹‰ä¸‹çš„é€†å…ƒ
void exgcd(int a, int b, int& x, int& y) {
    if (b == 0) {
      x = 1, y = 0;
      return;
    }
    exgcd(b, a % b, y, x);
    y -= a / b * x;
  }
```

## 5.5 gcd

```cpp
inline int gcd(int a,int b) {
    int r;
    while(b>0) {
        r=a%b;
        a=b;
        b=r;
    }
    return a;
}

inline int gcd1(int a,int b) {
    return b>0 ? gcd(b,a%b):a;
}

inline int gcd2(int a,int b) {
    while(b^=a^=b^=a%=b);
    return a;
}

inline int gcd3(int a,int b) {
	if(b) while((a%=b) && (b%=a));
	return a+b;
}
```

## 5.6 æ•°è®ºåˆ†å—

```cpp
#include<bits/stdc++.h>
#define int long long
const int N = 2e6+10;
#define PII pair<int, int>
using namespace std;

void solve(){
    int q;
    cin>>q;
    while(q--){
        int x;
        cin>>x;
        int ans = 0;
        for(int l = 1, r; l <= x; l = r + 1){
            r = x/(x/l);
            ans += (r-l+1)*(x/l);
            
        }
        cout << ans << endl;
    }
}
    
signed main(){
    IOS();
    int T = 1;
//     cin>>T;
    while(T--){
        solve();
    }
}
------------------------------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6 + 10;
const int M = 1e3 + 10;

int n, q;
int a[N], aa[N];//aæ˜¯åŸæ•°ç»„, aaæ˜¯æ’åºåçš„, ç›¸å½“äºç»´æŠ¤äº†æœ‰åºçš„å—
//belong[i] è¡¨ç¤ºç¬¬iä¸ªå…ƒç´ å±äºç¬¬å‡ å—
int belong[N];

struct node{
    int l, r;
    int lazy;
}block[M];//ç»´æŠ¤æ¯ä¸€ä¸ªåˆ†å—

void update_part(int j, int l, int r, int w){
    for(int i = l; i <= r; i++){
        a[i] += w;
    }
    l = block[j].l;
    int len = block[j].r - block[j].l + 1;
    memcpy(aa + l, a + l, sizeof(a[0]) * len);
    sort(aa + l, aa + l + len);
}

void update(int l, int r, int w){
    int b1 = belong[l], b2 = belong[r];
    if(b1 == b2){
        update_part(b1, l, r, w);
        return ;
    }
    for(int i = b1 + 1; i <= b2 - 1; i++){
        block[i].lazy += w;
    }
    update_part(b1, l, block[b1].r, w);
    update_part(b2, block[b2].l, r, w);
}

int query_part(int l, int r, int c){
    int ans = 0;
    for(int i = l; i <= r; i++){
        if(a[i] + block[belong[l]].lazy >= c) ans ++;
    }
    return ans;
}

int find(int j, int c){
    int l = block[j].l, r = block[j].r;
    int add = block[j].lazy;
    int idx = r + 1;
    while(l <= r){
        int mid = (l + r) >> 1;
        if(aa[mid] + add >= c){
            r = mid - 1;
            idx = mid;
        }
        else l = mid + 1;
    }
    return idx;
}

// æŸ¥è¯¢åŒºé—´ >= c çš„ä¸ªæ•°
int query(int l, int r, int c){
    int b1 = belong[l], b2 = belong[r];
    int ans = 0;
    if(b1 == b2){
        return query_part(l, r, c);
    }

    for(int i = b1 + 1; i <= b2 - 1; i++){
        ans += block[i].r - find(i, c) + 1;
    }
    return ans + query_part(l, block[b1].r, c) + query_part(block[b2].l, r, c);

}

void solve(){
    cin >> n >> q;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
        aa[i] = a[i];
    }
    int len = sqrt(n);//æ¯ä¸€å—çš„å¤§å°
    for(int i = 1; i <= n; i++){
        belong[i] = (i - 1) / len + 1;
    }
    int cnt = belong[n];//å—çš„ä¸ªæ•°
    for(int i = 1; i <= cnt; i++){
        block[i].l = (i - 1) * len + 1;
        block[i].r = min(i * len, n);
        sort(aa + block[i].l, aa + block[i].r + 1);
    }
    while(q--){
        char op;
        int l, r, w;
        cin >> op >> l >> r >> w;
        if(op == 'M'){
            update(l, r, w);
        }
        else{
            cout << query(l, r, w) << endl;            
        }
    }
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 5.7 çº¦æ•°ä¸ªæ•°

```cpp
#include<bits/stdc++.h>
const int MAXN=1e6+10;
using namespace std;
vector<int>pri;
bool flag[MAXN];
int d[MAXN],num[MAXN];
void pre(int n){
    d[1]=1;
    for(int i=2;i<=n;i++){
        if(!flag[i]){
            pri.push_back(i);
            d[i]=2;
            num[i]=1;
        }
        for(auto pri_j:pri){
            if(i*pri_j>n)break;
            flag[i*pri_j]=true;
            if(i%pri_j==0){
                num[i*pri_j]=num[i]+1;
                d[i*pri_j]=d[i]/num[i*pri_j]*(num[i*pri_j]+1);
                break;
            }
            num[i*pri_j]=1;
            d[i*pri_j]=d[i]*2;
        }
    }
}
signed main(){
    pre(100);
    cout<<d[9];
    return 0;
}
```

## 5.8 è¯•é™¤æ³•

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN=1e7;
int n;

void solve(){
    cin>>n;
    int num=sqrt(n);
    for(int i=2; i <= num; i++){
        if(n == 1) break;
        while(n%i == 0){
            n/=i;
            cout<<i<<" ";
        }
    }
    if(n!=1) cout<<n;
    cout<<endl;
}

signed main(){
    int T;
    cin>>T;
    while(T--){
        solve();
    }
    return 0;
}
```

## 5.9 è§„å¾‹

```cpp
å¡ç‰¹å…°æ•°
é€’æ¨å…¬å¼ : f[i] = 2*(2*n - 1) / (n + 1) * f[i - 1], f[0] = 1;
é€šé¡¹å…¬å¼ : f[i] = C(n, 2 * n) / (n + 1), Cæ˜¯ç»„åˆæ•°

æ–¯ç‰¹æ—æ•°
é€šé¡¹å…¬å¼ : {n, k} = {n - 1, k - 1} + k * {n - 1, k}, {n, k}ä¸ºç¬¬nè¡Œç¬¬kåˆ—çš„æ•°, éæ³•ä½ç½®åˆ°çš„æ•°ä¸º0

é”™ä½æ’åˆ—
a1 = 0, a2 = 1;
ai = (ai-1 + ai-2) * (i - 1), i >= 3

1/nçš„å‰né¡¹å’Œä¸ºloge(n)

lcm(a, b) = âˆi(1~n)pi^(max(ei, fi))
gcd(a, b) = âˆi(1~n)pi^(min(ei, fi))

ä¸¤ç‚¹ä¹‹é—´æ›¼å“ˆé¡¿è·ç¦»
d = abs(x1 - x2) + abs(y1 - y2)
åªæœ‰ä¸¤ç§æƒ…å†µabs((x1 + y1) - (x2 + y2)) || abs((x1 - y1) - (x2 - y2))

å®¹æ–¥åŸç†
æ±‚é›†åˆå¹¶é›†, AâˆªBâˆªC = (A + B + C) - (Aâˆ©B + Aâˆ©C + Bâˆ©C) + Aâˆ©Bâˆ©C
åŠ  â€œå¥‡æ•°ä¸ªé›†åˆçš„äº¤é›†â€, å‡ â€œå¶æ•°ä¸ªé›†åˆçš„äº¤é›†â€

å¯¹äºä¸€ç»„åºåˆ—, äº¤æ¢ä¸¤ä¸ªä¸åŒçš„æ•°å­—çš„ä½ç½®, åˆ™æ”¹å˜é€†åºå¯¹æ€»æ•°çš„å¥‡å¶æ€§

min(u, v) = (u + v) / 2 - |u - v| / 2

å–æ•´è§„åˆ™
å‘ä¸Šå–æ•´:
i128 x1 = y / x;
i128 re = y % x;
if(re && ((re > 0) == (x > 0))) x1++;
å‘ä¸‹å–æ•´:
i128 x1 = y / x;
i128 re = y % x;
if(re && ((re > 0) != (x > 0))) x1--;
```

## 5.10 é€†åºå¯¹

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 5e5 + 10;

int a[N],  tree[N];
int n, cnt;

int lowbit(int x){
    return x&-x;
}

void update(int x){
    for(int i = x; i <= n; i += lowbit(i)){
        tree[i] ++;
    }
}

int sum(int r){
    if(r == 0) return 0;
    int ans = 0;
    for(int i = r; i > 0; i -= lowbit(i)){
        ans += tree[i];
    }
    return ans;
}

int query(int l, int r){
    return sum(r) - sum(l-1);
}

void solve(){
    cin >> n;
    int ans = 0;
    map<int, int>mp;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
        mp[a[i]];
    }
    for(auto &[x, y] : mp){
        y = ++cnt;
    }
    for(int i = n; i >= 1; i--){
        int idx = mp[a[i]];
        ans += sum(idx - 1);
        update(idx);
    }
    cout << ans << endl;
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 5.11 è«é˜Ÿ

```cpp
//æ—¶é—´å¤æ‚åº¦O(nâˆšn)
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5 + 10;

struct Q{
    int l, r, idx;
}q[N];//ç¦»çº¿æ“ä½œ

int n, m, res;
int a[N], block[N], ans[N], mp[N];

//åŠ ç‚¹å¯¹åŒºé—´çš„å½±å“
void Add(int i){
    int cnt = mp[a[i]]++;
    res += cnt * (cnt - 1) / 2;
}

//å‡ç‚¹å¯¹åŒºé—´çš„å½±å“
void Sub(int i){
    int cnt = mp[a[i]]--;
    res -= (cnt - 1) * (cnt - 2) / 2;
}

void solve(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
    }
	//åˆ†å—
    int len = sqrt(n);
    for(int i = 1; i <= n; i++){
        block[i] = (i - 1) / len + 1;
    }
    for(int i = 1; i <= m; i++){
        cin >> q[i].l >> q[i].r;
        q[i].idx = i;
    }
	//å·¦ç«¯ç‚¹åœ¨ä¸€ä¸ªå—å†…å°±æŒ‰å³ç«¯ç‚¹æ’åºï¼Œå¦åˆ™æŒ‰å·¦ç«¯ç‚¹æ‰€å±å—æ’åº
    sort(q + 1, q + m + 1, [](const Q& x, const Q& y){
        return block[x.l] == block[y.l] ? x.r < y.r : block[x.l] < block[y.l];
    });    
    //ç»´æŠ¤ä¸€ä¸ªåŒºé—´[l, r]
    int l = 1, r = 0;
    for(int i = 1; i <= m; i++){
        //æ¯æ¬¡åªéœ€è¦åŠ ç‚¹æˆ–å‡ç‚¹, çœ‹è¯¥ç‚¹å¯¹åŒºé—´çš„å½±å“
        while(l > q[i].l) Add(--l);
        while(r < q[i].r) Add(++r);
        while(l < q[i].l) Sub(l++);
        while(r > q[i].r) Sub(r--);
        ans[q[i].idx] = res; 
    }
    for(int i = 1; i <= m; i++){
        cout << ans[i] << endl;
    }
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 5.12 FFT

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
#define double long double
const int N = 4e5 + 10;
const double PI = acos(-1);

struct cp{
    double x, y;
    cp (double xx = 0, double yy = 0) : x(xx), y(yy) {}
    cp operator + (const cp& b) {return cp(x + b.x, y + b.y);}
    cp operator - (const cp& b) {return cp(x - b.x, y - b.y);}
    cp operator * (const cp& b) {return cp(x * b.x - y * b.y, x * b.y + y * b.x);}
};

int rev[N], l;
int limit;

void init(){
    rev[0] = 0;
    // åœ¨åŸåºåˆ—ä¸­ i ä¸ i/2 çš„å…³ç³»æ˜¯ ï¼š iå¯ä»¥çœ‹åšæ˜¯i/2çš„äºŒè¿›åˆ¶ä¸Šçš„æ¯ä¸€ä½å·¦ç§»ä¸€ä½å¾—æ¥
    // é‚£ä¹ˆåœ¨åè½¬åçš„æ•°ç»„ä¸­å°±éœ€è¦å³ç§»ä¸€ä½ï¼ŒåŒæ—¶ç‰¹æ®Šå¤„ç†ä¸€ä¸‹å¥‡æ•°
    for(int i = 0; i < limit; i++){
        rev[i] = (rev[i >> 1] >> 1) | ((i&1) << (l - 1));
    }
}

void fft(vector<cp>& A, int op){
    for(int i = 0; i < limit; i++){ //æ±‚å‡ºè¦è¿­ä»£çš„åºåˆ—
        if(i < rev[i]) swap(A[i], A[rev[i]]);
    }
    for(int len = 1; len < limit; len <<= 1){ //å¾…åˆå¹¶åŒºé—´çš„é•¿åº¦çš„ä¸€åŠ
        cp Wn(cos(PI / len), op * sin(PI / len)); //å•ä½æ ¹
        for(int i = len << 1, j = 0; j < limit; j += i){ //iæ˜¯åŒºé—´çš„é•¿åº¦ï¼Œjè¡¨ç¤ºå‰å·²ç»åˆ°å“ªä¸ªä½ç½®äº†
            cp w(1, 0); //å¹‚
            for(int k = 0; k < len; k++, w = w * Wn){ //æšä¸¾å·¦åŠéƒ¨åˆ†
                cp x = A[j + k], y = w * A[j + len + k]; //è´è¶æ•ˆåº”
                A[j + k] = x + y;
                A[j + len + k] = x - y;
            }
        }
    }
}

void solve(){
    string s1, s2; cin >> s1 >> s2;
    int n = s1.size(), m = s2.size();
    reverse(s1.begin(), s1.end());
    reverse(s2.begin(), s2.end());
    limit = 1, l = 0;
    while(limit <= n + m - 2) limit <<= 1, l++;
    init();

    vector<cp>a(limit + 10), b(limit + 10);
    for(int i = 0; i < n; i++) a[i].x = (double)(s1[i] - '0');
    for(int i = 0; i < m; i++) b[i].x = (double)(s2[i] - '0');

    fft(a, 1), fft(b, 1);
    for(int i = 0; i < limit; i++) a[i] = a[i] * b[i];
    fft(a, -1);
    vector<int>ans(limit + 110);
    for(int i = 0; i <= n + m - 2; i++) ans[i] = (int)(a[i].x / limit + 0.5); //å››èˆäº”å…¥
    
    int r = n + m - 2;
//     for(int i = 0; i <= r; i++) cout << ans[i];
//     cout << endl;
    for(int i = 0; i <= r + 100; i++){
        int x1 = ans[i] / 2;
        ans[i + 2] -= x1;
        ans[i] %= 2;
        if(ans[i] == -1) ans[i] = 1, ans[i + 2]++;
    }    

    int mark = 0;
    for(int i = r + 100; i >= 0; i--){
        if(ans[i]){
            mark = 1;
        }
        if(mark) cout << ans[i];
    }
    if(!mark) cout << 0;
    cout << endl;
}

signed main(){
    int T = 1;
    cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```



<div style="page-break-after: always;"></div>

# 6 DPå¤§ç±»

## 6.1 å¤šé‡èƒŒåŒ…

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e4 + 10;

int n, m;
int dp[N], last[N];
int q[N];//å•è°ƒé˜Ÿåˆ—ï¼Œå­˜ä½“ç§¯

void solve(){
    cin >> n >> m;
    //å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–å¤šé‡èƒŒåŒ…
    for(int i = 1; i <= n; i++){
        int v, w, s;
        cin >> v >> w >> s;
        //æŒ‰ä½™æ•°åˆ†ç»„
        for(int j = 0; j < v; j++){

            int hh = 1, tt = 0;//å¤´å°¾æŒ‡é’ˆ
            for(int k = j; k <= m; k += v){
                //æ»‘åŠ¨çª—å£
                if(hh <= tt && q[hh] < k - s * v) hh++;
                if(hh <= tt ) dp[k] = max(dp[k], last[q[hh]] + (k - q[hh]) / v * w) ;
                //å‡å»åç§»é‡, æ¶ˆé™¤kçš„å½±å“
                while(hh <= tt && last[q[tt]] - (q[tt] - j) / v * w <= last[k] - (k - j) / v* w) tt--;
                q[++tt] = k;
            }
        }
        //è®°å½•dp[i-1]ä¸ºlast
        memcpy(last, dp, sizeof dp);
    }  

    // //äºŒè¿›åˆ¶ä¼˜åŒ–å¤šé‡èƒŒåŒ…, ç›¸å½“äºæŠŠsä¸ªç‰©å“åˆ†æˆlog(s)ä¸ªç‰©å“å†01èƒŒåŒ…
    // for(int i = 1; i <= n; i++){
    //     int v, w, s;
    //     cin >> v >> w >> s;
        
    //     for(int k = 1; k <= s; k *= 2){
    //         for(int j = m; j >= k * v; j--){
    //             dp[j] = max(dp[j], dp[j - k * v] + k * w);

    //         }
    //         s -= k;
    //     }

    //     if(s){
    //         for(int j = m; j >= s * v; j--){
    //             dp[j] = max(dp[j], dp[j - s * v] + s * w);
    //         }
    //     }    
    // }     
    cout << dp[m] << endl;
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 6.2 åŒºé—´dp

```cpp
//P1880 çŸ³å­åˆå¹¶
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2*100 + 10;

//åŒºé—´ DP å¸¸ç”¨æ¨¡ç‰ˆ
// for (int len = 1; len <= n; len++) {         // åŒºé—´é•¿åº¦
//     for (int l = 1; l + len - 1 <= n; l++) { // æšä¸¾èµ·ç‚¹
//         int r = i + len - 1;                 // åŒºé—´ç»ˆç‚¹
//         if (len == 1) {
//             dp[l][r] = åˆå§‹å€¼
//             continue;
//         }

//         for (int k = l; k < r; k++) {        // æšä¸¾åˆ†å‰²ç‚¹ï¼Œæ„é€ çŠ¶æ€è½¬ç§»æ–¹ç¨‹
//             dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r] + w[l][r]);
//         }
//     }
// }

int n;
int a[MAXN];
int pre[MAXN];
int dp1[MAXN][MAXN];
int dp2[MAXN][MAXN];

//æ—¶é—´å¤æ‚åº¦O(n^3)
void solve(){
    cin >> n;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
        a[i+n] = a[i];
    }
    for(int i = 1; i <= 2*n; i++){
        pre[i] = pre[i-1] + a[i];
    }
    memset(dp1, 0x3f, sizeof(dp1));
    memset(dp2, -0x3f, sizeof(dp2));
    // cout << dp2[0][0] << endl;
    int ans1 = INT_MAX, ans2 = INT_MIN;
    for(int len = 1; len <= n; len++){
        for(int i = 1; i <= 2*n - len + 1; i++){
            int j = i + len - 1;
            //åˆå§‹åŒ–
            if(len == 1){
                dp1[i][i] = 0;
                dp2[i][i] = 0;
                continue;
            }
            for(int k = i; k < j; k++){
                dp1[i][j] = min(dp1[i][j], dp1[i][k] + dp1[k+1][j] + pre[j] - pre[i-1]);
                dp2[i][j] = max(dp2[i][j], dp2[i][k] + dp2[k+1][j] + pre[j] - pre[i-1]);
            }
            if(len == n) ans1 = min(ans1, dp1[i][j]), ans2 = max(ans2, dp2[i][j]);
        }       
    }
    cout << ans1 << endl << ans2 << endl;
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 6.3 æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼ˆè´ªå¿ƒä¼˜åŒ–ï¼‰

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6 + 10;
const int M = 2e5 + 10;

int a[N], b[N];
int len;

int find(int x){
    int l = 1, r = len;
    int ans = 0;
    while(l <= r){
        int mid = (l + r) >> 1;
        if(b[mid] >= x){
            ans = mid;
            r = mid - 1; 
        }
        else l = mid + 1;
    }
    return ans;
}

void solve(){
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
    }
    for(int i = 1; i <= n; i++){
        if(a[i] > b[len]){
            b[++len] = a[i];
        }
        else{
            int j = find(a[i]);
            b[j] = a[i];
        }
    }
    cout << len << endl;
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 6.4 æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆè´ªå¿ƒä¼˜åŒ–ï¼‰

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long 
const int N = 1e6 + 10;
const int M = 2e5 + 10;

int n;
int a[N], b[N], c[N], mp[N];
int len;

int find(int x){
    int l = 1, r = len;
    int ans = 0;
    while(l <= r){
        int mid = (l + r) >> 1;
        if(c[mid] >= x){
            ans = mid;
            r = mid - 1;
        }
        else l = mid + 1;
    }
    return ans;
}

void solve(){
    cin >> n;
    //a[i]é‡Œçš„æ•°éƒ½ä¸é‡å¤
    for(int i = 1; i <= n; i++){
        cin >> a[i];
        mp[a[i]] = i;
    }      
    //è®©b[i]ç­‰äºå®ƒåœ¨a[i]å¯¹åº”çš„ä¸‹æ ‡, æ²¡æœ‰å°±æ˜¯ä¸‹æ ‡0
    for(int i = 1 ; i <= n; i++){
        cin >> b[i];
        b[i] = mp[b[i]];
    }
    for(int i = 1; i <= n; i++){
        if(b[i] == 0) continue;
        if(b[i] >= c[len]) c[++len] = b[i];
        else{
            int idx = find(b[i]);
            c[idx] = b[i];
        }
    }
    cout << len << endl;
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 6.5 æœ€é•¿å…¬å…±ä¸Šå‡å­åºåˆ—

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
const int N = 3e3 + 10;

void IOS(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
}

int n;
int a[N], b[N];
int dp[N][N]; // aå‰i, bä»¥jç»“å°¾çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦

void solve(){
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 1; i <= n; i++) cin >> b[i];
    // æ—¶é—´å¤æ‚åº¦O(n^3)
    int ans = 0;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            dp[i][j] = dp[i - 1][j];
            if(a[i] != b[j]) continue;
            int mx = 1;
            for(int k = 1; k < j; k++){
                if(b[j] > b[k])
                mx = max(mx, dp[i - 1][k] + 1);
            }
            dp[i][j] = max(dp[i][j], mx);
            ans = max(ans, dp[i][j]);
        }
    }
    cout << ans << endl;

    // æ—¶é—´å¤æ‚åº¦O(n^2)
    int ans = 0;
    for(int i = 1; i <= n; i++){
        int mx = 1;
        for(int j = 1; j <= n; j++){
            dp[i][j] = dp[i - 1][j];
            if(a[i] == b[j]) dp[i][j] = max(dp[i - 1][j], mx);
            if(b[j] < a[i]) mx = max(mx, dp[i - 1][j] + 1);
            ans = max(ans, dp[i][j]);
        }
    }
    cout << ans << endl;
    
}

signed main(){
    IOS();
    int T = 1;
    // cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```

## 6.6 çŠ¶å‹dp

```cpp
//p2831 äº’ä¸ä¾µçŠ¯
//çŠ¶å‹dpå¸¸ç”¨çŠ¶æ€: dp[å½“å‰é›†åˆ][å½“å‰çŠ¶æ€]
#include <bits/stdc++.h>
using namespace std;
#define int long long
//äº¤äº’é¢˜è®°å¾—æ³¨é‡Šæ‰
#define endl "\n"
const int N = 10 + 5;
const int M = 2e5 + 10;

//dp[i][j][state] è¡¨ç¤ºå‰iè¡Œ, jä¸ªå›½ç‹ä½ç½®ç¡®å®š, ç¬¬iè¡Œçš„çŠ¶æ€ä¸ºstateçš„æ–¹æ¡ˆæ€»æ•°
int dp[N][N * N][1ll << N];
int n, m;
// é¢„å¤„ç†cnt[i], ié‡Œé¢1çš„ä¸ªæ•°
int cnt[1ll << N]; 
// g[i] è¡¨ç¤ºç¬¬iä¸ªçŠ¶æ€æ—¶,ä¸Šä¸€è¡Œçš„åˆæ³•çŠ¶æ€çš„é›†åˆ, stateè¡¨ç¤ºä¸€è¡Œåˆæ³•çŠ¶æ€é›†åˆ
vector<int> g[1ll << N], state;

bool check(int x){
    for(int i = 0; i < n; i++){
        if((x >> i & 1) && (x >> i + 1 & 1)) return 0;
    }
    return 1;
}

int count(int x){ // xé‡Œ1çš„ä¸ªæ•°
    int tot = 0;
    for(int i = 0; i < n; i++){
        if(x >> i & 1) tot ++;
    }
    return tot;
}

void solve(){
    cin >> n >> m;
    for(int i = 0; i < 1ll << n; i++){
        if(check(i)){
            cnt[i] = count(i);
            state.push_back(i); // å­˜åˆæ³•çŠ¶æ€
        }
    }

    for(int i = 0; i < state.size(); i++){
        for(int j = 0; j < state.size(); j++){
            int a = state[i], b = state[j];
            //a & bä¿è¯ä¸Šä¸‹æ²¡æœ‰ç›¸é‚»çš„1, checkä¿è¯a,bæ²¡æœ‰è¿ç»­2ä¸ª1å¹¶ä¸”4ä¸ªå¯¹è§’ä¹Ÿæ²¡æœ‰1
            if((a & b) == 0 && check(a | b)){
                g[i].push_back(j);
            }
        }
    }
    int ans = 0;
    dp[0][0][0] = 1;
    for(int i = 1; i <= n + 1; i++){
        for(int j = 0; j <= m; j++){
            for(int k = 0; k < state.size(); k++){
                int a = state[k];
                if(j >= cnt[a]) //ä¸ªæ•°é™åˆ¶
                    for(auto l : g[k]) dp[i][j][k] += dp[i - 1][j - cnt[a]][l];
                if(i == n && j == m) ans += dp[n][m][k];
            }
        }
    }
    // cout << dp[n + 1][m][0] << endl;//ä¹Ÿå¯ä»¥è¿™æ ·
    cout << ans << endl; 
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 6.7 æœŸæœ›dp

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
const int N = 2e5 + 10;

int n;
double x1[N], x2[N], dp[N];
//x1[i]è¡¨ç¤ºä»¥iç»“å°¾çš„è¿ç»­1çš„é•¿åº¦çš„æœŸæœ›, è½¬ç§»æ–¹ç¨‹ x1[i] = (x1[i - 1] + 1) * pi
//x2[i]è¡¨ç¤ºä»¥iç»“å°¾çš„è¿ç»­1çš„é•¿åº¦çš„å¹³æ–¹çš„æœŸæœ›, è½¬ç§»æ–¹ç¨‹ x2[i] = (x2[i - 1] + 2 * x1[i - 1] + 1) * pi;
//dp[i]è¡¨ç¤ºä»¥1~içš„æ€»æœŸæœ›, è½¬ç§»æ–¹ç¨‹ dp[i] = dp[i - 1] + (3 * x2[i - 1] + 3 * x1[i - 1] + 1) * pi;
//å¢é‡ (x + 1)^3 - x^3 = 3*x^2 + 3*x + 1;

void solve(){
    cin >> n;
    double p;
    for(int i = 1; i <= n; i++){
        cin >> p;
        x1[i] = (x1[i - 1] + 1) * p;
        x2[i] = (x2[i - 1] + 2 * x1[i - 1] + 1) * p;
        dp[i] = dp[i - 1] + (3 * x2[i - 1] + 3 * x1[i - 1] + 1) * p;
    }    
    cout << fixed << setprecision(1) << dp[n] << endl;
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 6.8 æ ‘å½¢dp

```cpp
//P2015 äºŒå‰è‹¹æœæ ‘
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
const int N = 100 + 10;

int n, m, ans;
vector<PII>g[N];
int dp[N][N];// dp[i][j]è¡¨ç¤ºä»¥iä¸ºæ ¹çš„å­æ ‘, é€‰jä¸ªè¾¹çš„æœ€å¤§ä»·å€¼

void dfs(int u, int fa){ // åˆ†ç»„èƒŒåŒ…
    for(auto [v, w] : g[u]){// ç‰©å“
        if(v == fa) continue;
        dfs(v, u);
        for(int i = m; i > 0; i--){ // ä½“ç§¯
            for(int j = 0; j < i; j++){// å†³ç­–
                dp[u][i] = max(dp[u][i], dp[u][i - j - 1] + dp[v][j] + w);
            }
        }
    }
}

void solve(){
    cin >> n >> m;
    for(int i = 1; i < n; i++){
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }    
    dfs(1, 0);
    cout << dp[1][m] << endl;
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 6.9 æ•°ä½dp

```cpp
//P13085 windyæ•° 
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
const int N = 20;

// åšæ•°ä½dpçš„æ—¶å€™è€ƒè™‘â€œæ ‘â€å½¢
int l, r;
int dp[N][10];//dp[i][j] å«å‰å¯¼é›¶, i+1ä½(ä»0ä½å¼€å§‹çš„)æ•°å­—, ç¬¬iä½ä¸ºjçš„æ‰€æœ‰åˆæ³•æ•°å­—çš„æ•°é‡

void init(){
    for(int i = 0; i <= 9; i++) dp[0][i] = 1; 
    for(int i = 1; i < N; i++){
        for(int j = 0; j <= 9; j++){
            for(int k = 0; k <= 9; k++){
                if(abs(j - k) >= 2)
                dp[i][j] += dp[i - 1][k];
            }
            // cout << dp[i][j] << " \n"[j == 9];
        }
    }
}

int pre(int n){
    if(!n) return 0;
    vector<int>nums;
    while(n) nums.push_back(n % 10), n /= 10;
    n = nums.size();
    int ans = 0, last = -1;
    for(int i = n - 1; i >= 0; i--){
        int x = nums[i];
        for(int j = 0; j < x; j++){
            if(abs(j - last) >= 2)
                ans += dp[i][j];
        }
        
        if(abs(last - x) >= 2) last = x;
        else break; // ä¸åˆæ³•çš„çŠ¶æ€

        if(i == 0) ans++;
        // cout << ans << endl;
    }    

    for(int i = 0; i < n - 1; i++){ // æšä¸¾ä½ä½å¹¶ä¸”é¦–ä½ä¸ä¸ºé›¶çš„æ•°
        for(int j = 1; j <= 9; j++){
            ans += dp[i][j];
        }
    }
    return ans;
}

void solve(){
    cin >> l >> r;
    cout << pre(r) - pre(l - 1) << endl;
}

signed main(){
    init();
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

##  6.10 å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–dp

```cpp
//acwing 1089. çƒ½ç«ä¼ é€’
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
const int N = 5e5 + 10;

int n, m;
int w[N], dp[N], q[N];
// dp[i]è¡¨ç¤ºé€‰ç¬¬iä¸ªçƒ½ç«å°, å‰iä¸ªçƒ½ç«å°æ»¡è¶³æ¡ä»¶çš„æœ€å°èŠ±è´¹

void solve(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> w[i];
    }    

    int hh = 0, tt = 0, ans = 1e18;
    for(int i = 1; i <= n; i++){
        if(q[hh] < i - m) hh++;
        dp[i] = dp[q[hh]] + w[i];
        while(hh <= tt && dp[q[tt]] >= dp[i]) tt--;
        q[++tt] = i;

    }
    // ä»æœ€åmä¸ªé‡Œè‡³å°‘é€‰ä¸€ä¸ªçƒ½ç«å°, æ•…å–æœ€åmä¸ªdp[i]å³ä¸ºç­”æ¡ˆ
    for(int i = n - m + 1; i <= n; i++){ 
        ans = min(ans, dp[i]);
    }
    cout << ans << endl;
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 6.11 æ–œç‡ä¼˜åŒ–dp

```cpp
// acwing 301.ä»»åŠ¡å®‰æ’2
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
const int N = 5e5 + 10;

int n, s;
int dp[N];
int t[N], c[N], q[N];

void solve(){
    cin >> n >> s;
    for(int i = 1; i <= n; i++){
        cin >> t[i] >> c[i];
        t[i] += t[i - 1]; // å‰ç¼€t
        c[i] += c[i - 1]; // å‰ç¼€c
    }    

    // æ–œç‡ä¼˜åŒ–dp, æ ¹æ®dp[i]çš„è½¬ç§»dp[i] = t[i] * c[i] + s * c[n] + dp[j] - (s + t[i]) * c[j]
    // å°†æœªçŸ¥é‡dp[j], c[j]æ”¾åœ¨æ–¹ç¨‹ä¸¤è¾¹, å½¢æˆä¸€æ¬¡å‡½æ•°y = k * x + b
    // dp[j] = (s + t[i]) * c[j] + dp[i] - (t[i] + c[i] + s * c[n])
    // y = dp[j], k = (s + t[i]), x = c[j], b = dp[i] - (t[i] + c[i] + s * c[n])
    int hh = 0, tt = 0;
    q[0] = 0;
    for(int i = 1; i <= n; i++){
        // é˜Ÿåˆ—é‡Œçš„æ–œç‡åº”è¯¥ä¸ºä¸¥æ ¼å•è°ƒé€’å¢
        // å»æ‰é˜Ÿå¤´, k = (dp[q[hh + 1]] - dp[q[hh]]) / (c[q[hh + 1]] - c[q[hh]]) <= (t[i] + s)
        while(hh < tt && (dp[q[hh + 1]] - dp[q[hh]]) <= (t[i] + s) * (c[q[hh + 1]] - c[q[hh]])) hh++;
        int j = q[hh];

        // dp[i]çš„è½¬ç§»
        dp[i] = t[i] * c[i] + s * c[n] + dp[j] - (s + t[i]) * c[j];
        // é˜Ÿå°¾æ–œç‡k1 >= k2 , åˆ™å¼¹å‡ºé˜Ÿå°¾å…ƒç´ , (dp[q[tt]] - dp[q[tt - 1]]) / (c[q[tt]] - c[q[tt - 1]]) >= (dp[i] - dp[q[tt]]) / (c[i] - c[q[tt]])
        while(hh < tt && (dp[q[tt]] - dp[q[tt - 1]]) * (c[i] - c[q[tt]]) >= (dp[i] - dp[q[tt]]) * (c[q[tt]] - c[q[tt - 1]])) tt--;
        q[++tt] = i;
    }

    cout << dp[n] << endl;
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 6.12 å·®å€¼èƒŒåŒ…

```cpp
//https://ac.nowcoder.com/acm/contest/114806/M
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
using i64 = long long;
const int N = 3e4 + 10;

int n, w[N], v[N];
int dp[N];

void solve(){
    cin >> n;
    for(int i = 1; i <= n; i++){
        cin >> w[i];
    }
   
    for(int i = 1; i <= n; i++){
        cin >> v[i];
        v[i] = w[i] - v[i];
    }
    int offset = 1e4;
    memset(dp, -0x3f, sizeof dp);
    dp[offset] = 0;
    for(int i = 1; i <= n; i++){
        if(v[i] >= 0){
            for(int j = 2e4; j >= v[i]; j--){
                dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
            }
        }
        else{
            for(int j = 0; j <= 2e4; j++){
                dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
            }
        }
    }
    cout << dp[offset] << endl;
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

## 6.13 æ¢æ ¹dp

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define double long double
#define endl "\n"
#define PII pair<int, int>
#define x first
#define y second
const int N = 5e5 + 10;
const int M = 64;
const int mod = 998244353;

void IOS(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
}

int n;
vector<int>g[N];
int down[N][10], up[N][10];
// down[i][j]èŠ‚ç‚¹iå­æ ‘é‡Œ, è·ç¦»èŠ‚ç‚¹iæœ‰jæ­¥çš„ç‚¹çš„ä¸ªæ•°
// up[i][j]èŠ‚ç‚¹içš„ç¥–å…ˆé‡Œ, è·ç¦»èŠ‚ç‚¹iæœ‰jæ­¥çš„ç‚¹çš„ä¸ªæ•°

void dfs1(int u, int fa){
    down[u][0] = 1;
    for(auto v : g[u]){
        if(v == fa) continue;
        dfs1(v, u);
        int x = v;
        for(int j = 1; j <= 9; j++){
            down[u][j] += down[v][j - 1];
        }
    }
}

void dfs2(int u, int fa){
//     up[u][0] = 1;
    for(auto v : g[u]){
        if(v == fa) continue;
        for(int j = 1; j <= 9; j++){
            if(j >= 1)
            up[v][j] += up[u][j - 1] + down[u][j - 1];
            if(j >= 2) up[v][j] -= down[v][j - 2];
        }
        dfs2(v, u);
    }
}

void solve(){
    cin >> n;
    for(int i = 1; i < n; i++){
        int u, v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    
    dfs1(1, 0);
    dfs2(1, 0);
//     for(int i = 1; i <= n; i++){
//         for(int j = 0; j <= 9; j++){
//             cout << up[i][j] << " \n"[j == 9];
//         }
//     }
    for(int i = 1; i <= n; i++) cout << down[i][9] + up[i][9] << " ";
    
}

signed main(){
    IOS();
    int T = 1;
//     cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```

## 6.14 çŸ©é˜µå¿«é€Ÿå¹‚ä¼˜åŒ–dp

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
#define PII pair<int, int>
#define x first
#define y second
#define double long double
const int N = 10 + 10;
const int M = 64;
const int mod = 998244353;

void IOS(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
}

int n, m, K, R;
int a[N], c[N], ack[1 << 6], cost[1 << 6];
// Aæ˜¯å¯è¾¾çŸ©é˜µ, Gæ˜¯ç­”æ¡ˆçŸ©é˜µ, Bæ˜¯åº•æ•°çŸ©é˜µ
int A[1 << 6][1 << 6], G[1 << 6][1 << 6], B[1 << 6][1 << 6];
int t[1 << 6][1 << 6];

// çŸ©é˜µä¹˜æ³•
void mul(int A1[][1 << 6], int A2[][1 << 6]){
    // tæ˜¯ä¸´æ—¶æ•°ç»„, ç”¨ä¸´æ—¶æ•°ç»„å­˜ç­”æ¡ˆç„¶åå†æ›´æ–°
    memset(t, 0, sizeof t); 
    for(int k = 0; k < (1 << n); k++){
        for(int i = 0; i < (1 << n); i++){
            for(int j = 0; j < (1 << n); j++){
                t[i][j] = max(t[i][j], A1[i][k] + A2[k][j]);
            }
        }
    }

    memcpy(A1, t, sizeof t);
}

void ksm(){
    while(R){
        if(R&1) mul(G, B);
        R >>= 1;
        mul(B, B);
    }
}

void solve(){
    cin >> n >> m >> K >> R;
    for(int i = 0; i < n; i++) cin >> a[i] >> c[i];

    for(int i = 0; i < (1ll << n); i++){
        ack[i] = cost[i] = 0;
        for(int j = 0; j < n; j++){
            if(i >> j & 1) ack[i] += a[j], cost[i] += c[j];
        }
        // cout << ack[i] << endl;
    }

    for(int i = 0; i < (1ll << n); i++){
        for(int j = 0; j < (1ll << n); j++){
            A[i][j] = G[i][j] = B[i][j] = 0;
            int cnt = 0;
            for(int k = 0; k < n; k++){
                if((j >> k & 1) && (i >> k & 1)) cnt++;
            }

            if(cost[j] + cnt * K <= m) A[i][j] = 1;
            else A[i][j] = 0;
            
            if(A[i][j]) B[i][j] = ack[j];
        }
    }

    ksm();
    int ans = 0;

    for(int j = 0; j < (1ll << n); j++){
        ans = max(ans, G[0][j]);
    }

    cout << ans << endl;
}

signed main(){
    IOS();
    int T = 1;
    cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```



<div style="page-break-after: always;"></div>

# 7 è®¡ç®—å‡ ä½•

## 7.1 å‡¸åŒ…

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
const int N = 2e5 + 10;
struct VEX{
    double x, y;
    VEX(double xx = 0, double yy = 0) : x(xx), y(yy){}
    double operator* (const VEX & v2) const {
        return x * v2.x + y * v2.y;
    }
    double operator^ (const VEX & v2) const {
        return x * v2.y - y * v2.x;
    }
    VEX operator- (const VEX & v2) const {
        return VEX(x - v2.x, y - v2.y);
    }
    VEX operator+ (const VEX & v2) const {
        return VEX(x + v2.x, y + v2.y);
    }
    bool operator== (const VEX & v2) const {
        return x == v2.x && y == v2.y;
    }
};

double dis(const VEX &v1,const VEX &v2){
    VEX v = v1 - v2;
    return sqrt(v.x * v.x + v.y * v.y);
}

//æŒ‰åæ ‡æ’åº
bool cmp(const VEX &v1, const VEX &v2){
    return (v1.x != v2.x ? v1.x < v2.x : v1.y > v2.y);
}

double cross(VEX &v1, VEX &v2, VEX &v3){
    return ((v2 - v1) ^ (v3 - v2));
}

int n;
VEX a[N], st[N];

//Andrewç®—æ³•
double Andrew(){
    double ans = 0;//ç®—å‡¸åŒ…æœ€å°å‘¨é•¿
    sort(a + 1, a + n + 1, cmp);
    int top = 0;
    for(int i = 1; i <= n; i++){
        while(top > 1 && cross(st[top - 1], st[top], a[i]) <= 0) top--;
        st[++top] = a[i];
    }
    int t = top;
    for(int i = n - 1; i >= 1; i--){
        while(top > t && cross(st[top - 1], st[top], a[i]) <= 0) top--;
        st[++top] = a[i];
    }

    for(int i = 1; i < top; i++){
        ans += dis(st[i], st[i + 1]);
    }

    return ans;
}

//æè§’æ’åº, ç”¨atan2éœ€æ³¨æ„, å‚æ•°ä¸¥æ ¼æŒ‰å‘é‡æ¥çš„atan2(y, x) != atan2(-y, -x)
//atan2å€¼åŸŸ[-PI, PI], ç¬¬3,4,1,2è±¡é™è§’åº¦é€’å¢
bool cmp1(const VEX& v1, const VEX& v2){ 
    double ang1 = atan2(v1.y - a[1].y, v1.x - a[1].x), ang2 = atan2(v2.y - a[1].y, v2.x - a[1].x);
    if(ang1 - ang2 == 0) return dis(a[1], v1) < dis(a[1], v2);
    else return ang1 < ang2;
}

//ç”¨å‰ç§¯å†™æè§’æ’åº
bool cmp2(const VEX& v1, const VEX& v2){
    double cross = (v1 - a[1]) ^ (v2 - a[1]);
    if(cross == 0) return dis(v1, a[1]) < dis(v2, a[1]);
    return cross > 0;
}

//Grahamç®—æ³•
double Graham(){
    for(int i = 2; i <= n; i++){
        if(a[i].y < a[1].y || a[i].y == a[1].y && a[i].x < a[1].x){
            swap(a[i], a[1]);
        }
    }
    sort(a + 2, a + n + 1, cmp2);
    int top = 0;

    double ans = 0;
    for(int i = 1; i <= n; i++){
        while(top > 1 && cross(st[top - 1], st[top], a[i]) < 0) top--;
        st[++top] = a[i];
    }
    st[++top] = a[1];
    for(int i = 1; i < top; i++){
        ans += dis(st[i], st[i + 1]);
    }

    return ans;
}

void solve(){
    cin >> n;
    for(int i = 1; i <= n; i++){
        cin >> a[i].x >> a[i].y;
    }
    cout << fixed << setprecision(2) << Graham() << endl;
}

signed main(){
    int T = 1;
    while(T--){
        solve();
    }
    return 0;
}
```

<div style="font-size: 9px; text-align: center; margin-top: 10px;">


